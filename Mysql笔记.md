# 4、索引

## 索引的常见类型

### 哈希表

​	优点：插入新数据会很快

​	缺点：索引无序，无法做范围查询，仅可做等值查询

### 有序数组

​	优点：可做等值查询和范围查询

​	缺点：插入新数据效率低，仅适用于静态存储引擎

### 二叉树

​	优点：搜索效率最高

​	缺点：索引会存储到磁盘中，如果树太深，访问磁盘的次数就变多。

​	改进：为了让一个查询尽量少地读磁盘， 就必须让查询过程访问尽量少的数据块。 那么， 我们就不应该

使用二叉树， 而是要使用“N叉”树。 这里， “N叉”树中的“N”取决于数据块的大小 。

>待查询:
>
>1. 二叉搜索树
>2. 跳表
>3. LSM树

## InnoDB的索引模型

B+树，每一个索引对应一个B+树。**B+树能够很好地配合磁盘的读写特性， 减少单次查询的磁盘访问次数。**  

InnoDB是索引组织表， **一般情况下需要创建一个自增主键， 这样非主键索引占用的空间最小。** 

>1）B-Tree
>
>在看B+Tree之前，我们先看看B-Tree
>
>B-Tree是一种为外查找（磁盘类外存储设备，数据量太大不能全放在内存里）而设计的平衡多叉树。那为什么用B树而不用其他的如二叉树、平衡二叉树呢？
>
>原因在于当存储关键字个数确定后，用B树进行存储所需要的最大树高相对于二叉树、平衡二叉树要小。这能够减小IO次数，从而提高检索效率。换句话说，使用B树能够确保，访问到任意数据的IO请求的最大次数是确定的。
>
>2）B+Tree
>
>所谓的B+Tree和B-Tree的区别仅仅在于，B-Tree的所有节点均用于存储键或者值。而B+Tree只有叶子节点才用于存储数据，而非叶子节点用于存储键。
>
>B+Tree是对B-Tree的一种优化。因为当非叶子节点存储的值占位太多时，便会增加树的高度。树高的增加带来的是IO的增加。

### 索引类型

​	主键索引（聚簇索引（clustered index） ），主键索引的叶子节点存的是整行数据  

​	非主键索引（二级索引），非主键索引的叶子节点内容是主键的值  

### 基于主键索引与普通索引的区别是什么？

如果语句是select * from T where ID=500， 即主键查询方式， 则只需要搜索ID这棵B+树；
如果语句是select * from T where k=5， 即普通索引查询方式， 则需要先搜索k索引树， 得到ID
的值为500， 再到ID索引树搜索一次。 这个过程称为回表。



也就是说， 基于非主键索引的查询需要多扫描一棵索引树。 因此， 我们在应用中**应该尽量使用主**
**键查询**  

## 索引维护

### 页分裂（会降低性能和空间效率）

R5所在的数据页已经满了， 根据B+树的算法， 这时候需要申请一个新的数据页， 然后挪动部分数据过去。 这个过程称为页分裂。

 除了性能外， 页分裂操作还影响数据页的利用率。 原本放在一个页的数据， 现在分到两个页中，整体空间利用率降低大约50%。  

### 哪些场景下应当使用自增主键

1. 递增插入的场景

>如果是业务逻辑的字段做主键，不可保证有序插入。成本较高
>
>除了考虑性能外， 我们还可以从存储空间的角度来看。 假设你的表中确实有一个唯一字段， 比如
>字符串类型的身份证号， 那应该用身份证号做主键， 还是用自增字段做主键呢？
>
>由于每个非主键索引的叶子节点上都是主键的值。 如果用身份证号做主键， 那么每个二级索引的
>叶子节点占用约20个字节， 而如果用整型做主键， 则只要4个字节， 如果是长整型（bigint） 则是
>8个字节。  
>
>显然， 主键长度越小， 普通索引的叶子节点就越小， 普通索引占用的空间也就越小。
>所以， 从性能和存储空间方面考量， 自增主键往往是更合理的选择  

### 有没有什么场景适合用业务字段直接做主键的呢？  （KV场景）

1. 只有一个索引；
2. 该索引必须是唯一索引。  

*直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树*  

