## MySql 属于 C/S 架构

我们日常使用MySQL的情景一般是这样的:

- 启动MySQL服务器程序
- 启动MySQL客户端程序并连接到服务器程序
- 在客户端程序中输入一些命令语句作为请求发送到服务器程序，服务器程序收到这些请求后，会根据请求的内容来操作具体的数据并向客户端返回操作结果

> 什么是数据库实例？

计算机上运行的每一个程序也称为一个进程。运行过程中的MySQL服务器程序和客户端程序从本质上来说也算是计算机的进程，其中代表**MySQL服务器程序的进程称为MySQL数据库实例。**

## 服务器处理客户端请求

![img](https://s1.ax1x.com/2020/03/25/8jY49x.png)

### 连接管理（连接器）

每当有一个客户端进程连接到服务器进程时，服务器进程都会创建一个线程来专门处理与这个客户端的交互，当该客户端退出时会与服务器断开连接，**服务器并不会立即把与该客户端交互的线程销毁掉，而是把它缓存起来**，在另一个新的客户端再进行连接时，把这个缓存的线程分配给该新客户端

>建立连接有哪些方式？
>
>TCP/IP，命名管道，共享内存，UNIX域套接字等几种方式。

### 查询缓存

**从MySQL 5.7.20开始，不推荐使用查询缓存，并在MySQL 8.0中删除。**

> MySQL服务器程序会把刚刚处理过的查询请求和结果缓存起来，如果下一次有一模一样的请求过来，直接从缓存中查找结果就好了，就不用再傻呵呵的去底层的表中查找了。这个查询缓存可以在不同客户端之间共享，也就是说如果客户端A刚刚查询了一个语句，而客户端B之后发送了同样的查询请求，那么客户端B的这次查询就可以直接使用查询缓存中的数据。如果两个查询请求在任何字符上的不同（例如：空格、注释、大小写），都会导致缓存不会命中。如果查询请求中包含某些系统函数、用户自定义变量和函数、一些系统表，如 mysql 、information_schema、 performance_schema 数据库中的表，那这个请求就不会被缓存。
>
> > 那么缓存什么时候会失效？
>
> MySQL的缓存系统会监测涉及到的每张表，只要该表的结构或者数据被修改，如对该表使用了INSERT、 UPDATE、DELETE、TRUNCATE TABLE、ALTER TABLE、DROP TABLE或 DROP DATABASE语句，那使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除

### 语法解析（分析器）

这个从指定的文本中提取出我们需要的信息本质上算是一个编译过程，涉及词法解析、语法分析、语义分析等阶段

### 查询优化（优化器）

语法解析之后，服务器程序获得到了需要的信息，比如要查询的列是哪些，表是哪个，搜索条件是什么等等，但光有这些是不够的，因为我们写的MySQL语句执行起来效率可能并不是很高，MySQL的优化程序会对我们的语句做一些优化

### 存储引擎

截止到服务器程序完成了查询优化为止，还没有真正的去访问真实的数据表，MySQL服务器把数据的存储和提取操作都封装到了一个叫存储引擎的模块里。我们知道表是由一行一行的记录组成的，但这只是一个逻辑上的概念，**物理上如何表示记录，怎么从表中读取数据，怎么把数据写入具体的物理存储器上，这都是存储引擎负责的事情。**为了实现不同的功能，MySQL提供了各式各样的存储引擎，不同存储引擎管理的表具体的存储结构可能不同，采用的存取算法也可能不同。

![img](https://s1.ax1x.com/2020/03/25/8jUtBD.png)

其实我们最常用的就是`InnoDB和MyISAM`, 不同引擎支持的功能不一样.

- 查看当前服务器程序支持的存储引擎

  > SHOW ENGINES;

  ![img](https://s1.ax1x.com/2020/03/25/8jUHDU.png)

  - Transactions列代表该存储引擎是否支持事务处理。XA列代表着该存储引擎是否支持分布式事务。Savepoints代表着该存储引擎是否支持部分事务回滚。

- 设置表的存储引擎

  > CREATE TABLE 表名( 建表语句; ) ENGINE = 存储引擎名称;

- 修改表的存储引擎

  > ALTER TABLE 表名 ENGINE = 存储引擎名称;

### 注意点：

1. server层和存储引擎层交互时，一般是以记录为单位的。以SELECT语句为例，server层执行计划先向存储引擎层取一条记录，然后判断是否符合WHERE的条件，如果符合，就先将其发送到一个缓冲区，待该缓冲区满了，才向客户端发送真正的记录。该缓冲区的大小是由系统变量net_buffer_length控制。

### 补充知识点：

#### MySQL 体系结构

这个非常重要，理解了之后后面的一些知识点才能懂，比如索引下推。

MySQL 体系结构可以分为两大块来看，分别是：Server 和存储引擎。

![图片](https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nGNCEu9Hcibia6vBa6nupCz4IVl5G5viaK81QJBrsXa1ibf1micqBLpvG7bWJH2KmwbDibrlTkdZUVeoIng/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

当客户端与 MySQL 建立连接之后，一条 SQL 语句经过 TCP 从客户端传输到 Server ，Server 会先将语句进行词法分析与语法分析，这个工作是分析器做的。

如果语法有问题，那这个错误相信大家都不陌生：`You have an error in your SQL syntax; check the manual......`

确认语法没问题之后，会再经由优化器来决策这条语句是否需要重写，如何选择驱动表，如何选择合适的索引等操作，目的就是让语句更高效的执行。

我们平日里用的 explain 其实就是让 MySQL 告诉我们它的优化决定策略是怎样的。

至此，MySQL 已经知道该做什么和怎么做了，此时就是执行器干活时候了，它会调用存储引擎的接口来执行语句。

**第一个关键点来了。**

例如我现在要执行一条`select * from yes where name='yes的练级攻略';`这条语句，name 这一列没有索引。

此时流程如下：

1. Server 调用存储引擎的`返回这个表的第一行`这个接口，此时 Server 拿到第一行数据。
2. Server 通过 where 条件判断 name 是否等于`yes的练级攻略`，如果是则放到结果集中，不是则跳过。
3. Server 继续调用存储引擎的接口`来下一行！`，然后再通过 where 条件来判断。
4. 如此循环往复，直到最后一行记录。
5. 不会等结果全部收集完毕了才返回给客户端，等集满`net_buffer`大小的结果就会发送，也就是边查边发。

从以上流程可以得知，where 的条件如果用不上索引，那是在 Server 层做过滤的，如果你平日 exlplain 时候从 extra 里看到 `using where`，那就是在 Server 层利用 where 做了过滤的意思。

然后就是存储引擎的接口。MySQL 的存储引擎是插件式的，一个数据库里面的不同表可以用不同的存储引擎，而 Server 都是同一个，所以需要规定好统一的接口，这样 Server 才好调用不同的存储引擎。

像上面提到的`返回这个表的第一行`就是一个标准的接口，如果 name 这一列有索引的话，那就是走`返回符合这个条件的第一行`。从这里我们也可以得知走索引更好，因为这样能利用索引快速过滤得到正确的数据，不走索引就是一条一条拉到 Server 层走 where 过滤。

还有就是上面提到的 MySQL 是边查边发的，其实稍微想想就知道，如果 MySQL 要等结果集全了之后再发送数据给客户端，这样的设计不仅慢，而且如此多的查询需要缓存完整的结果集， MySQL 的内存早就挤爆了。

至此，我相信你脑海里应该可以浮现一条 SQL 的执行路径了，你已经有点感觉了。

我再来丰富一下上面的图，把优化器之类的加上去。

![图片](https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nGNCEu9Hcibia6vBa6nupCz4IVXWgMzzAMT5GDaGKCfO4dzFpLdXJr9kPbDy9v8JTiaNny8goPibKvTdw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

对了，你可能在别的地方会看到还有个缓存组件，用于查询缓存，具体做法就是将一个查询语句作为 key ，将上一次请求的结果作为 value，存储在缓存组件中，当同样的语句来查询的时候即可立马返回结果，不需要经历词法、语法分析等以下的步骤。

这个东西在 MySQL 8.0 之后就被砍了，并且只要表有数据改动缓存就失效了，在我们常见的 OLTP 场景下是个鸡肋，索性就不画了，清爽比较重要。

>OLTP，也叫联机事务处理（Online Transaction Processing），表示事务性非常高的系统，一般都是高可用的在线系统，以小的事务以及小的查询为主，评估其系统的时候，一般看其每秒执行的Transaction以及Execute SQL的数量。在这样的系统中，单个数据库每秒处理的Transaction往往超过几百个，或者是几千个，Select 语句的执行量每秒几千甚至几万个。典型的OLTP系统有电子商务系统、银行、证券等，如美国eBay的业务数据库，就是很典型的OLTP数据库。

## 总结

为了管理方便，人们把`连接管理、查询缓存、语法解析、查询优化`这些并不涉及真实数据存储的功能划分为`MySQL server`的功能，把真实存取数据的功能划分为`存储引擎`的功能。各种不同的存储引擎向上边的MySQL server层提供统一的`调用接口（也就是存储引擎API）`，包含了几十个底层函数，像"读取索引第一条内容"、"读取索引下一条内容"、"插入记录"等等。