## InnoDB行

我们平时是以记录为单位来向表中插入数据的，这些记录在磁盘上的存放方式也被称为行格式或者记录格式。InnoDB存储引擎到现在为止设计了4种不同类型的`行格式`，分别是Compact、Redundant、Dynamic和Compressed行格式

## **compact(行格式)**

![img](https://s1.ax1x.com/2020/03/31/GMNX7t.png)

记录的额外信息这部分信息是服务器为了管理这条记录而不得不额外添加的一些信息，这些额外信息分为3类，分别是`变长字段长度列表、NULL值列表和记录头信息`

------

### **<u>变长字段长度列表</u>**

变长的数据类型，比如VARCHAR(M)、VARBINARY(M)、各种TEXT类型，各种BLOB类型，我们也可以把拥有这些数据类型的列称为变长字段，变长字段中存储多少字节的数据是不固定的，这种字段叫做变长字段.

对于变长字段, 除了存储真实值外, 还需要将真实值的长度使用`变长字段长度列表`记录

**在Compact行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表，各变长字段数据占用的字节数按照列的顺序逆序存放**

>注意：
>
>InnoDB在读取记录的变长字段长度列表时先查看表结构。如果某个变长字段允许存储的最大字节数不大于255，则可以认为只使用1字节来表示真实数据占用的字节数。
>
>如果变长字段允许存储的最大字节数超过255字节，并且展示数据占用的字节数超过127字节，则使用2字节来表示真实诗句占用的字节数，否则使用1字节。

变长字段长度列表中只存储值为 非NULL 的列内容占用的长度，值为 NULL 的列的长度是不储存的

并不是所有记录都有这个 `变长字段长度列表` 部分，比方说表中所有的列都不是变长的数据类型的话，这一部分就不需要有。

------

### **<u>NULL值列表</u>**

表中的某些列可能存储NULL值，如果把这些NULL值都放到记录的真实数据中存储会很占地方，所以Compact行格式把这些值为NULL的列统一管理起来，存储到NULL值列表中.

主键列、被NOT NULL修饰的列都是不可以存储NULL值的，所以在统计的时候不会把这些列算进去

如果表中没有允许存储 NULL 的列，则 NULL值列表 也不存在了

二进制位的值为1时，代表该列的值为NULL。
二进制位的值为0时，代表该列的值不为NULL。

MySQL规定NULL值列表必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补0. (一个字节=8位)，

**因为是逆序排列，所以第一个列c1要和最后一个二进制位对应（最低位）。**
![img](https://s1.ax1x.com/2020/03/31/GM6ceU.png)
以此类推，如果一个表中有9个允许为NULL，那这个记录的NULL值列表部分就需要2个字节来表示了。

------

### **<u>记录头信息</u>**

它是由固定的5个字节组成。5个字节也就是40个二进制位，不同的位代表不同的意思

![img](https://s1.ax1x.com/2020/03/31/GM4LRg.md.png)

![img](https://s1.ax1x.com/2020/03/31/GM5pd0.png)

------

### **<u>隐藏列</u>**

除了上述的信息外, innnodb还为每条记录添加了隐藏列, 分别是: row_id(行id), transaction_id(事务id), roll_pointer(回滚指针)

> InnoDB表对主键的生成策略：优先使用用户自定义主键作为主键，如果用户没有定义主键，则选取一个Unique键作为主键，如果表中连Unique键都没有定义的话，则InnoDB会为表默认添加一个名为row_id的隐藏列作为主键。所以我们从上表中可以看出：InnoDB存储引擎会为每条记录都添加 transaction_id 和 roll_pointer 这两个列，但是 row_id 是可选的（在没有自定义主键以及Unique键的情况下才会添加该列）。这些隐藏列的值不用我们操心，InnoDB存储引擎会自己帮我们生成的。

------

## **<u>char(M) 与 varchar(M)</u>**

这两个类型的列, 在界定是否为可变长度的列是, 主要取决于列使用的字符集是否是定长的, 比如 **ascII字符集是定长为1字节(8位),** **而utf8是不定长的, 一个字符要占用1-3字节. char(10) 类型的列要占用的字节为 10-30字节.**

varchar(M)中M的最大值也要取决于列的字符集类型, 正常如果是 ascII字符集, 一个字符=1字节时, 最大长度也不能为 65535, 因为还需要给出标识是否为null等等信息的空间. 所以根据字符集的定长, 可以计算出M的最大值.

![img](https://s1.ax1x.com/2020/03/31/GQPkE6.md.png)

>MySQL要求一个行的定义长度不能超过65535。
>
>（1）单个字段如果大于65535，则转换为TEXT 。
>
>（2）单行最大限制为65535，这里不包括TEXT、BLOB。
>
>所谓单行最大限制指的就是一张表中所有字段的所设置的长度不得超过65535字节，
>
>例如一个表中有三个varchar字段长度30000，那么这个表的单行长度为：30000*3=90000，
>
>大于65535则报错不能建表，这里乘以3是因为数据库用的utf8编码，3个字节表示一个字符。

## 记录中的数据太多产生的行溢出

有如下所示数据库脚本语句:

```sql
mysql> CREATE TABLE varchar_size_demo(
    ->       c VARCHAR(65532)
    -> ) CHARSET=ascii ROW_FORMAT=Compact;
Query OK, 0 rows affected (0.01 sec)

mysql> INSERT INTO varchar_size_demo(c) VALUES(REPEAT('a', 65532));
Query OK, 1 row affected (0.00 sec)
```

MySQL中磁盘和内存交互的基本单位是页，也就是说MySQL是以页为基本单位来管理存储空间的，我们的记录都会被分配到某个页中存储。而一个页的大小一般是16KB，也就是16384字节，而一个VARCHAR(M)类型的列就最多可以存储65532个字节，这样就可能造成一个页存放不了一条记录的尴尬情况。

> 在Compact和Redundant行格式中，对于占用存储空间非常大的列，在记录的真实数据处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中，然后记录的真实数据处用20个字节存储指向这些页的地址（当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页，如图所示：
> ![img](https://s1.ax1x.com/2020/03/31/GQkE5V.png)
>
> ------
>
> 从图中可以看出来，对于Compact和Redundant行格式来说，如果某一列中的数据非常多的话，在本记录的真实数据处只会存储该列的前768个字节的数据和一个指向其他页的地址，然后把剩下的数据存放到其他页中，这个过程也叫做
>
> ```
> 行溢出
> ```
>
> ，存储超出768字节的那些页面也被称为
>
> ```
> 溢出页
> ```
>
> , 不只是 VARCHAR(M) 类型的列，其他的 TEXT、BLOB 类型的列在存储数据非常多的时候也会发生行溢出, 所以你不用关注这个临界点是什么，只要知道如果我们一条记录的某个列中存储的数据占用的字节数非常多时，该列就可能成为溢出列.

## Dynamic和Compressed行格式

> 为什么要介绍行溢出, 是因为要引出 Dynamic 和 Compress 行格式

> 它们不会在记录的真实数据处存储字段真实数据的前768个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储20字节大小的指向溢出页的地址（当然，这20字节还包括真实数据占用的字节数），就像这样：
> ![img](https://s1.ax1x.com/2020/03/31/GQZxXD.png)
>
> ------
>
> Compressed 行格式和 Dynamic 不同的一点是，Compressed 行格式会采用压缩算法对页面进行压缩，以节省空间.
>
> ------
>
> MySQL5.7，它的默认行格式就是 Dynamic