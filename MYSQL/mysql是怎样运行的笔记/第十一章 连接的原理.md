## 连接简介

### 连接的本质

```sql
mysql> CREATE TABLE t1 (m1 int, n1 char(1));
Query OK, 0 rows affected (0.02 sec)

mysql> CREATE TABLE t2 (m2 int, n2 char(1));
Query OK, 0 rows affected (0.02 sec)

mysql> INSERT INTO t1 VALUES(1, 'a'), (2, 'b'), (3, 'c');
Query OK, 3 rows affected (0.00 sec)
Records: 3  Duplicates: 0  Warnings: 0

mysql> INSERT INTO t2 VALUES(2, 'b'), (3, 'c'), (4, 'd');
Query OK, 3 rows affected (0.00 sec)
Records: 3  Duplicates: 0  Warnings: 0
```

![img](https://s1.ax1x.com/2020/04/03/GNUSET.png)

> 连接的本质就是把各个连接表中的记录都取出来依次匹配的组合加入结果集并返回给用户。所以我们把t1和t2两个表连接起来的过程如下图所示：
> ![img](https://s1.ax1x.com/2020/04/03/GNaKe0.md.png)
>
> ------
>
> 连接查询的结果集中包含一个表中的每一条记录与另一个表中的每一条记录相互匹配的组合，像这样的结果集就可以称之为笛卡尔积。因为表t1中有3条记录，表t2中也有3条记录，所以这两个表连接之后的笛卡尔积就有3×3=9行记录。在MySQL中，连接查询的语法也很随意，只要在FROM语句后边跟多个表名就好了，比如我们把t1表和t2表连接起来的查询语句可以写成这样：

### 多表的过滤条件

下边这个查询语句：

> SELECT * FROM t1, t2 WHERE t1.m1 > 1 AND t1.m1 = t2.m2 AND t2.n2 < 'd';

那么这个连接查询的大致执行过程如下：

> 首先确定第一个需要查询的表，这个表称之为驱动表。只需要选取代价最小的那种访问方法去执行单表查询语句就好了（就是说从const、ref、ref_or_null、range、index、all这些执行方法中选取代价最小的去执行查询）
>
> ------
>
> 因为是根据t1表中的记录去找t2表中的记录，所以t2表也可以被称之为被驱动表。上一步骤从驱动表中得到了2条记录，所以需要查询2次t2表。此时涉及两个表的列的过滤条件t1.m1 = t2.m2就派上用场了：
>
> - 当t1.m1 = 2时，过滤条件t1.m1 = t2.m2就相当于t2.m2 = 2，所以此时t2表相当于有了t2.m2 = 2、t2.n2 < 'd'这两个过滤条件，然后到t2表中执行单表查询。
> - 当t1.m1 = 3时，过滤条件t1.m1 = t2.m2就相当于t2.m2 = 3，所以此时t2表相当于有了t2.m2 = 3、t2.n2 < 'd'这两个过滤条件，然后到t2表中执行单表查询。
>
> ------
>
> 所以整个连接查询的执行过程就如下图所示：

这个两表连接查询共需要查询1次t1表，2次t2表。当然这是在特定的过滤条件下的结果，如果我们把t1.m1 > 1这个条件去掉，那么从t1表中查出的记录就有3条，就需要查询3次t2表了。也就是说在两表连接查询中，驱动表只需要访问一次，被驱动表可能被访问多次。

## 内连接和外连接

```sql
CREATE TABLE student (
    number INT NOT NULL AUTO_INCREMENT COMMENT '学号',
    name VARCHAR(5) COMMENT '姓名',
    major VARCHAR(30) COMMENT '专业',
    PRIMARY KEY (number)
) Engine=InnoDB CHARSET=utf8 COMMENT '学生信息表';

CREATE TABLE score (
    number INT COMMENT '学号',
    subject VARCHAR(30) COMMENT '科目',
    score TINYINT COMMENT '成绩',
    PRIMARY KEY (number, subject)
) Engine=InnoDB CHARSET=utf8 COMMENT '学生成绩表';
```

![img](https://s1.ax1x.com/2020/04/03/GN63Yq.md.png)

现在我们想把每个学生的考试成绩都查询出来就需要进行两表连接了（因为score中没有姓名信息，所以不能单纯只查询score表）。连接过程就是从student表中取出记录，在score表中查找number相同的成绩记录，所以过滤条件就是student.number = socre.number，整个查询语句就是这样：

![img](https://s1.ax1x.com/2020/04/03/GN6YlT.png)

上表的查询结果中并没有全部的学生信息, 因为有一些学生缺考了. 我们想将缺考的学生信息同时也查出来, mysql 提供了`内连接和外连接`帮我们实现:

> 对于内连接的两个表，驱动表中的记录在被驱动表中找不到匹配的记录，该记录不会加入到最后的结果集，我们上边提到的连接都是所谓的内连接。
>
> 对于外连接的两个表，驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集。在 MySQL中，根据选取驱动表的不同，外连接仍然可以细分为2种：左外连接和右外连接

可是这样仍然存在问题，即使对于外连接来说，有时候我们也并不想把驱动表的全部记录都加入到最后的结果集。这时就需要两种过滤条件来帮助解决.

### where 和 on 子句

WHERE子句中的过滤条件就是我们平时见的那种，不论是内连接还是外连接，凡是不符合WHERE子句中的过滤条件的记录都不会被加入最后的结果集。

对于外连接的驱动表的记录来说，如果无法在被驱动表中找到匹配ON子句中的过滤条件的记录，那么该记录仍然会被加入到结果集中，对应的被驱动表记录的各个字段使用NULL值填充。

> 一般情况下，**我们都把只涉及单表的过滤条件放到 WHERE 子句中，把涉及两表的过滤条件都放到 ON 子句中**，我们也一般把放到ON子句中的过滤条件也称之为连接条件。

### 左（外）连接的语法

左（外）连接的语法还是挺简单的，比如我们要把t1表和t2表进行左外连接查询可以这么写：

> SELECT * FROM t1 LEFT [OUTER] JOIN t2 ON 连接条件 [WHERE 普通过滤条件];

对于左（外）连接和右（外）连接来说，必须使用ON子句来指出连接条件。

### 右（外）连接的语法

右（外）连接和左（外）连接的原理是一样一样的，语法也只是把LEFT换成RIGHT而已：

> SELECT * FROM t1 RIGHT [OUTER] JOIN t2 ON 连接条件 [WHERE 普通过滤条件];

### 内连接的语法

内连接和外连接的根本区别就是在驱动表中的记录不符合ON子句中的连接条件时不会把该记录加入到最后的结果集:

> SELECT * FROM t1 [INNER | CROSS] JOIN t2 [ON 连接条件] [WHERE 普通过滤条件];

还有一种省略的写法:

> SELECT * FROM t1, t2;

## 连接的原理

真正的重点来了, 在理解了mysql 使用了什么算法来实现的连接原理以后, 才能真正将连接写得好.

### 循环嵌套连接算法

![img](https://s1.ax1x.com/2020/04/03/GaVABR.png)

用伪代码表示一下这个过程就是这样：

```csharp
for each row in t1 {   #此处表示遍历满足对t1单表查询结果集中的每一条记录
    
    for each row in t2 {   #此处表示对于某条t1表的记录来说，遍历满足对t2单表查询结果集中的每一条记录
    
        for each row in t3 {   #此处表示对于某条t1和t2表的记录组合来说，对t3表进行单表查询
            if row satisfies join conditions, send to client
        }
    }
}
```

这个过程就像是一个嵌套的循环，所以这种驱动表只访问一次，但被驱动表却可能被多次访问，访问次数取决于对驱动表执行单表查询后的结果集中的记录条数的连接执行方式称之为嵌套循环连接（Nested-Loop Join），这是最简单，也是最笨拙的一种连接查询算法。

### 使用索引加快连接速度

当两个表连接查询时, 被驱动表肯定是拿着驱动表单表最优查询的结果, 进行多次查询. 如果每次查询刚刚好都查询在被驱动表所建立的索引上, 效率可能会提升不少. (主要是看这个索引对于数据库的访问方法是否高效)

### 基于块的循环嵌套连接

扫描一个表的过程其实是先把这个表从磁盘上加载到内存中，然后从内存中比较匹配条件是否满足。实际生产环境两个表的数据量都非常大的情况, 内存里可能并不能完全存放的下表中所有的记录，所以在扫描表前边记录的时候后边的记录可能还在磁盘上，等扫描到后边记录的时候可能内存不足，所以需要把前边的记录从内存中释放掉。

采用`嵌套循环连接算法`的两表连接过程中，被驱动表可是要被访问好多次的，如果这个被驱动表中的数据特别多而且不能使用索引进行访问，那就相当于要从磁盘上读好几次这个表，这个I/O代价就非常大了，所以我们得想办法：尽量`减少访问被驱动表的次数`。

为了解决被驱动表数据量很大, 每次使用驱动表的结果逐条去与被驱动表中所有数据进行比对, 则可能驱动表的结果集有多少条数据, 就要从磁盘中取出被驱动表的数据多少次. 这样做显然是太慢了. mysql 提出当拿出一部分被驱动表的数据后, 就整体与驱动表的结果集都比对一次, 这样会减少被驱动表的数据取出的次数. 所以这一部分数据先要放在一个叫做 `join buffer`的区域. 默认大小是 256kb,

另外需要注意的是，驱动表的记录并不是所有列都会被放到join buffer中，只有`查询列表中的列和过滤条件中的列`才会被放到join buffer中，所以再次提醒我们，`最好不要把*作为查询列表，只需要把我们关心的列放到查询列表就好`了，这样还可以在join buffer中放置更多的记录