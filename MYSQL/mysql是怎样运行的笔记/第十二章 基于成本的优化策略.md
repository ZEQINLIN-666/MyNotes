## mysql 执行查询的成本

### I/O成本

> 我们的表经常使用的MyISAM、InnoDB存储引擎都是将数据和索引都存储到磁盘上的，当我们想查询表中的记录时，需要先把数据或者索引加载到内存中然后再操作。这个从磁盘到内存这个加载的过程损耗的时间称之为I/O成本。

### CPU成本

> 读取以及检测记录是否满足对应的搜索条件、对结果集进行排序等这些操作损耗的时间称之为CPU成本。

### 成本常数

> 对于InnoDB存储引擎来说，页是磁盘和内存之间交互的基本单位，设计MySQL的大叔规定读取一个页面花费的成本默认是1.0，读取以及检测一条记录是否符合搜索条件的成本默认是0.2。需要注意的是，不管读取记录时需不需要检测是否满足搜索条件，其成本都算是0.2。

## 建表

```sql
CREATE TABLE single_table (
    id INT NOT NULL AUTO_INCREMENT,
    key1 VARCHAR(100),
    key2 INT,
    key3 VARCHAR(100),
    key_part1 VARCHAR(100),
    key_part2 VARCHAR(100),
    key_part3 VARCHAR(100),
    common_field VARCHAR(100),
    PRIMARY KEY (id),
    KEY idx_key1 (key1),
    UNIQUE KEY idx_key2 (key2),
    KEY idx_key3 (key3),
    KEY idx_key_part(key_part1, key_part2, key_part3)
) Engine=InnoDB CHARSET=utf8;
```

## 基于成本的优化步骤

查询优化器执行一条查询之前的准备工作如下:

> 根据搜索条件，找出所有可能使用的索引
> 计算全表扫描的代价
> 计算使用不同索引执行查询的代价
> 对比各种执行方案的代价，找出成本最低的那一个

比如一个单表查询语句如下：

```sql
SELECT * FROM single_table WHERE 
    key1 IN ('a', 'b', 'c') AND 
    key2 > 10 AND key2 < 1000 AND 
    key3 > key2 AND 
    key_part1 LIKE '%hello%' AND
    common_field = '123';
```

首先找到这条查询语句使用到了哪些索引呢. key1,和 key2都是, 其他的均不是.（key3呢？）

然后计算全表扫描的成本, 以及分别以 key1 和 key2 作为二级索引的成本. 找出最优查询成本即可.

## 两表连接的成本分析

连接查询的成本计算公式是这样的：

> 连接查询总成本 = 单次访问驱动表的成本 + 驱动表扇出数 x 单次访问被驱动表的成本

对于左（外）连接和右（外）连接查询来说，它们的驱动表是固定的，所以想要得到最优的查询方案只需要：

> 分别为驱动表和被驱动表选择成本最低的访问方法。

可是对于内连接来说，驱动表和被驱动表的位置是可以互换的，所以需要考虑两个方面的问题：

> 不同的表作为驱动表最终的查询成本可能是不同的，也就是需要考虑最优的表连接顺序。
>
> 然后分别为驱动表和被驱动表选择成本最低的访问方法。

结论:

> 我们需要尽量`在被驱动表的连接列上建立索引`，这样就可以使用ref访问方法来降低访问被驱动表的成本了。如果可以，`被驱动表的连接列最好是该表的主键或者唯一二级索引列，这样就可以把访问被驱动表的成本降到更低了`。