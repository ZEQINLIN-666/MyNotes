# 什么是事务？

事务是逻辑上的一组操作，要么都执行，要么都不执行。

事务最经典的例子就是转账。假如小明要给小红转账1000元，这个转账就会涉及两个关键操作

1. 将小明的余额减少1000元
2. 将小红的余额增加1000元

万一在这两个操作之间，突然出现了错误。比如银行系统崩溃，导致小明的余额减少而小红的余额没有增加，这就不对了。

**事务就是保证这两个关键操作要么都成功，要么都失败**

# 事务的特性（ACID）

1. **原子性：**事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
2. **一致性：**执行事务前后，数据保持一致。例如在转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的。（上例子固定为2000元）
3. **隔离性：**在并发访问数据库时，一个用户的事务不被其他的事务所干扰，各并发事务之间的数据库是独立的；
4. **持久性：**一个事务被提交之后。它对数据库中的数据的改变是持久的，及时数据库发生故障也不应该对其有任何影响。

## 问题1：MySQL是怎么保证原子性的。

答：是利用InnoDB的`undo log`逻辑日志，它记录的是SQL执行相关的信息。

`undo log`名为回滚日志，是实现原子性的关键。当事务回滚时能够撤销所有已经成功执行的SQL语句，他需要记录你要回滚的相应的日志信息。

例如

- 当你delete一条数据的时候，就需要记录这条数据的信息，回滚的时候，insert这条旧数据。
- 当你update一条数据的时候，就需要记录之前的旧值，回滚的时候，根据旧值执行update操作（update语句在执行undo log回滚时有可能会涉及到MVCC。主要是为了保证在执行undo log的时候的select能看到哪个版本的数据。）
- 当你insert一条数据的时候，就需要记录这条记录的主键，回滚的时候，根据主键执行delete操作。

`undo log`记录了这些回滚需要的信息，当事务执行失败或者调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。

`ps:`undo log的具体细节，待阅读《MySQL是怎样运行的》

## 问题2：MySQL是怎样保持隔离性的

原子性和持久性都是基于单个事务内部的措施，而隔离性是指多个事务之间的相互隔离，互不影响的特性。

我们都知道事务的隔离级别中最严谨的是串行化（Serializable），但是隔离性越高，性能就越低，所以一般不使用串行化这个隔离级别。

对于隔离性，我们要分两种情况讨论：

- 一个事务中的写操作对另一个事务中的写操作的影响；
- 一个事务中的写操作对另一个事务中的读操作的影响；

**首先，事务间的写操作其实是靠MySQL的锁机制来实现隔离的，而事务间的读写操作是靠MVCC机制来实现的。**

### **锁机制：**

MySQL中的锁主要有：

按照功能分：读锁和写锁

按照作用范围分：表级锁和行级锁

还有意向锁和间隙锁等。



**读锁:**又称“共享锁”，是指多个事务可以共享一把锁，都只能访问数据，并不能修改

**写锁:**又称"排他锁"，是不能和其他事务共享数据的，如果一个事务获取到了一个数据的排他锁，那么其他事务就不能再获取该行的其他锁，包括共享锁和排他锁。



**表级锁：**是指会将整个表进行锁定，性能较差，不同存储引擎支持的锁的粒度不同

MyISAM引擎支持表级锁，InnoDB引擎支持表级锁也支持行级锁。

**行级锁**：会将需要操作的相应行进行锁定，性能好。



**意向锁：**意向锁是表级锁，如果在一个事务已经对一个表中的某个数据加上了排他锁或共享锁，那么就可以加上意向锁，这样当下一个事务来进行锁表的时候发现已经存在意向锁了，就会先被阻塞。如果不加意向锁的话，第二个事务来锁表的时候就需要一行一行的遍历查看是否有数据已经被锁住的。

**间隙锁**：间隙锁是为了防止产生幻读而加的锁，加载不存在的空闲空间，可以是两个索引记录之间，也可能是第一个索引记录之前或者最后一个索引之后的空间（但是并不包含当前记录）。这样就保证了在间隙锁执行的时候，新增的数据会阻塞，保证了一个事务中的两次查询获取的记录数都是一致的。



**Next-Key Lock：**是行级锁和间隙锁的结合产生的锁，因为间隙锁是不会锁住当前记录的，而Next-Key Lock是会将当前记录也锁住的。

例如：如果一个表中有三条数据分别是：

| id   | name | number |
| :--- | :--- | :----- |
| 1    | 小明 | 16     |
| 2    | 小红 | 17     |
| 3    | 小张 | 20     |
| 4    | 小王 | 20     |

那么在执行SQL：select * from table where number = 17 for update 时，

间隙锁会锁住，number的区间是：（16，17），（17，20），

但是Next-Key Lock的锁住的是：（16，17），（17，20）区间加间隙锁，同时number=17加记录锁。

**锁机制保障了多个事务间的写操作的隔离，而多个事务间的读和写操作的保证是需要通过MVCC机制来保证的。**

### MVCC机制

MVCC全程是【Mutil-Version ConCurrency Control】即多版本控制机协议。

MVCC主要是靠在每行记录上增加隐藏列和使用undo log来实现的，隐藏列主要包括：更改行数据创建的版本号（递增的），删除时间，指向undo log的指针等。

那么MVCC是如何保证读写隔离的呢？主要是通过`快照读`和`当前读`两个操作。

- 快照读：

  MVCC为了保证并发的效率，在进行读取数据的时候是不加锁的，在执行select的时候（不加锁的普通select），会先读取当前数据的版本号，如果在select还没返回结果时，有事务将此行数据进行了修改，那么版本号就会比执行select的时候的大，所以为了保证select读取数据的一致性，就只会读取小于或等于当前版本的数据，这个历史版本的数据就是从undo log中获取到了。

- 当前读：

  当执行insert、update、delete的时候，是读取的当前最新的版本数据，并且会给当前记录加上锁，用来保证在操作的时候不会被别的事务对版本号进行修改。

像普通的select就是快照读，即读取的有可能就是数据的历史版本。

insert、update、delete、select...lock in share mode和select ... for update读取的就是当前读，即读取的都是数据的最新版本。



其实将隔离级别设置为Serializable也是可以实现读写隔离的，但是并发效率会低很多，所以一般用的很少，但是MVCC是读不加锁的。只有在写的时候才会加锁，从而提高了并发的效率。

通过MVCC机制保证了多个事务间的读写隔离，从而实现了事务的隔离性。



## 问题3：MySQL是怎样保持持久性的？

我们都知道MySQL的数据最终都是存放在磁盘中的。所以才会有磁盘的容量大小决定数据容量的大小。但是如果对MySQL的操作都是通过读写磁盘来进行的话，那么光是磁盘的I/O就能把效率拉得很低。

所以InnoDB为MySQL提供了缓冲池（Buffer Pool），BufferPool中包含了磁盘中部分数据页的映射。

当从数据库读取数据时，会先从Buffer Pool中读取数据，如果Buffer Pool中没有，则从磁盘读取后放入到Buffer Pool中。

当向数据库写入数据时，会先写入到Buffer Pool中，Buffer Pool中更新的数据会定期刷新到磁盘中（这个过程叫做刷脏）

>虽然Buffer Pool为MySQL的读写提高了效率，但是却也带来了新的问题，那就是如果数据刚更新到Buffer Pool中还没来得及刷新到磁盘时，MySQL突然宕机了，这就会导致数据丢失，造成事物的持久性无法保证了。

为了解决这个缓存的一致性问题，redo log就出现了。

在对Buffer Pool中的数据进行修改的时候，通过redo log记录这次操作，当事务提交时，会通过fsync接口对redo log进行刷盘。

因为在事务提交时是会把redo log同步在磁盘中的，所以当MySQL出现宕机时，可以从磁盘中读取redo log进行数据的恢复，从而保证了事务的持久性。



redo log采用的是预写的方式记录日志。即先记录日志，再更新Buffer Pool，这样就强行保证了：数据只要保存在了redo log中就一定会存储到磁盘中。



这里需要解释一下，redo log也是写磁盘，刷脏也是写磁盘，为啥要先记录redo log，而不是直接刷脏？

主要原因就是：redo log比刷脏快的多。

1. redo log是追加操作日志，是顺序IO；而刷脏是随机IO，因为每次更新的数据不一定是挨着的，也就是随机的。
2. 刷脏是以数据页（Page）为单位的（即每次最少从磁盘中读取一页数据到内存，或者最少刷一页数据到磁盘中），**MySQL默认页大小是16K**，对一个页上的修改，都要整个页刷到磁盘中；而redo log只包含真正的需要写入磁盘的操作日志。

MySQL还有一个记录操作的日志，叫做binlog，那么binlog和redo log又有什么区别？

- 作用上的区别：

  redo log是用来记录更新缓存的，为了保证MySQL就算宕机也不会影响事务的持久性

  binlog是用来记录什么时间操作了什么，主要有时间点，可以保证将数据恢复到某个时间点，也有用于主从同步数据的。

- 层次上的区别：

  redo log是存储引擎InnoDB实现的（MyISAM就没有redo log），而binlog是在MySQL服务器层面存在的，任何其他存储引擎也有redo log

  在存储内容上，redo log是物理日志，是基于磁盘的数据页，binlog是逻辑日志，存储的是一条执行的SQL

- 写入时机的区别

  redo log在默认情况下是在事务提交时，进行刷盘的；可以通过参数`innodb_flush_log_at_trx_commit`来改变策略，可以不用等到事务提交时才进行刷盘。

  如：可以设置为每秒提交一次

  **binlog是在事务提交时写入的。**

## 问题4：MySQL是怎样保持一致性的

一致性是指在事务执行前后，数据的一致性，事务前后数据完整性没有被破坏，并且都是合法的数据状态。

- 其中一致性的指标有：

  索引的完整（唯一索引，不重复等），数据列的完整（字段类型，长度，大小符合要求），外键约束等。

- 实现一致性的措施：

  保证原子性、持久性、隔离性，如果这些特性都无法保证，那么一致性就无法保证。

  从数据库层面，出了前面那几个特性的保证外，对字段的一致性是有保证措施的。例如整形的字符不能传入，字符串，时间等格式，字符串的长度不能超过列的限制。

  但是在应用层面也是需要开发者自己来保证的。

  例如：从A转账给B一部分金额，那么就要保证，A扣钱，B加钱。如果只扣除A的金额，而没有增加B的金额，是无法保证一致性的。

**另外，MySQL还通过两阶段提交事务，保证了redo log和binlog之间的数据一致性问题。**

在默认情况下，事务提交时，即写redo log又写binlog那么他们是如何协调一致性的呢？事务提交成功以写入哪个日志为准呢？

MySQL通过两阶段提交来保证这两个日志的数据一致性。

- 第一阶段提交，将redo log提交到磁盘，并将状态更改为`prepare`状态，binlog不做任何操作。
- 第二阶段提交，
  - 1、生成事务操作的binlog，并将binlog写入到磁盘中
  - 2、调用引擎的提交事务接口，将redo log的状态从`prepare`改为`commit`，事务提交完成

通过上面两个阶段提交保证了事务数据的一致性。

当事务提交redo log处于`prepare`阶段时，发生MySQL宕机或者崩溃，则会执行事务回滚

当事务提交redo log 处于commit阶段时发生了崩溃，会执行事务恢复，本机事务通过redo log进行恢复，而如果是主从数据库的话，在commit阶段，会根据binlog对从库进行数据恢复。

**这就是以写入binlog成功为提交事务成功的依据。**

因为一般在崩溃恢复的时候，都是用binlog进行恢复的，如果还未生成binlog，只写入redo log。在恢复的时候redo log恢复的是一个版本的数据，而通过bin log恢复的从库数据会是之前的一个时间点的binlog版本的数据，这样数据就导致不一致了。

----

# 总结MySQL事务

MySQL事务的ACID，一致性是最终目的。

保证一致性的措施有：

原子性：靠undo log来保证（异常或者执行失败后进行回滚）

持久性：靠redo log来保证(保证MySQL宕机或者停电后，可以通过redo log最终将数据永久保存到磁盘中)

隔离性：事务间的写操作靠MySQL的锁机制来保证隔离，事务间的读写操作靠MVCC机制（快照读，当前读）来保证隔离性。

一致性：事务的最终目的。即需要数据库层面保证，有需要应用层面进行保证，并且MySQL底层通过两阶段提交事务保证了事务持久化时的一致性。





# 并发事务带来的问题

在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对统一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。

- **脏读（Dirty read）:** 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。
- **丢失修改（Lost to modify）:** 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。
- **不可重复读（Unrepeatableread）:** 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。
- **幻读（Phantom read）:** 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。

**不可重复读和幻读的区别**

**不可重复读的重点是修改，幻读的重点在于新增或者删除**

例1：（同样的条件，你读取过的数据，再读取一次发现**值**不一样了）：

事务1中的A先生读取自己的工资为1000的操作还没完成，事务2的B先生就修改了A的工资为2000，导致A再读自己的工资时工资变为2000；这就是不可重复读

例2（同样的条件，第一次和第二次读出来的**记录数**不一样）：

假设某工资单表中工资大于3000的有4人，事务1读取所有工资大于3000的人，共查到4条记录，这时事务2又插入了一条工资大于3000的记录，事务1再次读取时查到的记录就变为了5条，这样就导致了幻读。

# 事务隔离级别

**SQL 标准定义了四个隔离级别：**

- **READ-UNCOMMITTED(读取未提交)：** 最低的隔离级别，允许读取尚未提交的数据变更，**可能会导致脏读、幻读或不可重复读**。
- **READ-COMMITTED(读取已提交)：** 允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻读或不可重复读仍有可能发生**。
- **REPEATABLE-READ(可重复读)：** 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生**。
- **SERIALIZABLE(可串行化)：** 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**。

| 隔离级别         | 脏读 | 不可重复读 | 幻影读 |
| ---------------- | ---- | ---------- | ------ |
| READ-UNCOMMITTED | √    | √          | √      |
| READ-COMMITTED   | ×    | √          | √      |
| REPEATABLE-READ  | ×    | ×          | √      |
| SERIALIZABLE     | ×    | ×          | ×      |

MySQL InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ（可重读）**。

我们可以通过`SELECT @@tx_isolation;`命令来查看,MySQL 8.0 该命令改为`SELECT @@transaction_isolation;`

```mysql
mysql> SELECT @@tx_isolation;
+-----------------+
| @@tx_isolation  |
+-----------------+
| REPEATABLE-READ |
+-----------------+
```

这里需要注意的是：

与SQL标准不同的地方在于，**InnoDB存储引擎在REPEATABLE-READ（可重读）事务隔离级别下，允许应用使用Next-Key Lock锁算法来避免幻读的产生**，这与其他数据库系统（SQL server）是不同的。

所以说虽然 InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ（可重读）** ，但是可以通过应用加锁读（例如 `select * from table for update` 语句）来保证不会产生幻读，而这个加锁度使用到的机制就是 Next-Key Lock 锁算法。从而达到了 SQL 标准的 **SERIALIZABLE(可串行化)** 隔离级别。

因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是**READ-COMMITTED(读取提交内容):**，但是你要知道的是InnoDB 存储引擎默认使用 **REPEATABLE-READ（可重读）** 并不会有任何性能损失。

InnoDB 存储引擎在 **分布式事务** 的情况下一般会用到**SERIALIZABLE(可串行化)** 隔离级别。

# 实际情况演示

在下面我会使用 2 个命令行mysql ，模拟多线程（多事务）对同一份数据的脏读问题。

MySQL 命令行的默认配置中事务都是自动提交的，即执行SQL语句后就会马上执行 COMMIT 操作。如果要显式地开启一个事务需要使用命令：`START TARNSACTION`。

我们可以通过下面的命令来设置隔离级别。

```mysql
SET [SESSION|GLOBAL] TRANSACTION ISOLATION LEVEL [READ UNCOMMITTED|READ COMMITTED|REPEATABLE READ|SERIALIZABLE]
```

我们再来看一下我们在下面实际操作中使用到的一些并发控制语句:

- `START TARNSACTION` |`BEGIN`：显式地开启一个事务。
- `COMMIT`：提交事务，使得对数据库做的所有修改成为永久性。
- `ROLLBACK`：回滚会结束用户的事务，并撤销正在进行的所有未提交的修改。

#### 脏读(读未提交)

[![img](https://camo.githubusercontent.com/de00a9acaf2e8e378238dcbd23cc5f25c7eeab2f6efd98ac1265b1032f57c281/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d33312d31e8848fe8afbb28e8afbbe69caae68f90e4baa429e5ae9ee4be8b2e6a7067)](https://camo.githubusercontent.com/de00a9acaf2e8e378238dcbd23cc5f25c7eeab2f6efd98ac1265b1032f57c281/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d33312d31e8848fe8afbb28e8afbbe69caae68f90e4baa429e5ae9ee4be8b2e6a7067)

#### 避免脏读(读已提交)

[![img](https://camo.githubusercontent.com/cdc254ad6dba62cbb8e502902a4ff702126b445ad7c5de82646b0f31246f1798/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d33312d32e8afbbe5b7b2e68f90e4baa4e5ae9ee4be8b2e6a7067)](https://camo.githubusercontent.com/cdc254ad6dba62cbb8e502902a4ff702126b445ad7c5de82646b0f31246f1798/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d33312d32e8afbbe5b7b2e68f90e4baa4e5ae9ee4be8b2e6a7067)

#### 不可重复读

还是刚才上面的读已提交的图，虽然避免了读未提交，但是却出现了，一个事务还没有结束，就发生了 不可重复读问题。

[![img](https://camo.githubusercontent.com/5bf72a5658006bc45026bc18f6d3123229511ec9693de3ba79d5b057b428b7b6/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d33322d31e4b88de58fafe9878de5a48de8afbbe5ae9ee4be8b2e6a7067)](https://camo.githubusercontent.com/5bf72a5658006bc45026bc18f6d3123229511ec9693de3ba79d5b057b428b7b6/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d33322d31e4b88de58fafe9878de5a48de8afbbe5ae9ee4be8b2e6a7067)

#### 可重复读

[![img](https://camo.githubusercontent.com/ccf179af3e11a9c795717789e35f597f2732f45c8de11a22f2969d9079390423/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d33332d32e58fafe9878de5a48de8afbb2e6a7067)](https://camo.githubusercontent.com/ccf179af3e11a9c795717789e35f597f2732f45c8de11a22f2969d9079390423/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d33332d32e58fafe9878de5a48de8afbb2e6a7067)

#### 防止幻读(可重复读)

[![img](https://camo.githubusercontent.com/6df09345ce0e04e96b5dd24b43d4a6463f5262914c7a5b4e32b10f115c273a46/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d3333e998b2e6ada2e5b9bbe8afbb28e4bdbfe794a8e58fafe9878de5a48de8afbb292e6a7067)](https://camo.githubusercontent.com/6df09345ce0e04e96b5dd24b43d4a6463f5262914c7a5b4e32b10f115c273a46/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d3333e998b2e6ada2e5b9bbe8afbb28e4bdbfe794a8e58fafe9878de5a48de8afbb292e6a7067)

一个事务对数据库进行操作，这种操作的范围是数据库的全部行，然后第二个事务也在对这个数据库操作，这种操作可以是插入一行记录或删除一行记录，那么第一个是事务就会觉得自己出现了幻觉，怎么还有没有处理的记录呢? 或者 怎么多处理了一行记录呢?

幻读和不可重复读有些相似之处 ，但是不可重复读的重点是修改，幻读的重点在于新增或者删除。