# 1、MYSQL的基础架构

[![c04czn.png](https://z3.ax1x.com/2021/04/11/c04czn.png)](https://imgtu.com/i/c04czn)







# 4、索引

## 索引的常见类型

### 哈希表

​	优点：插入新数据会很快

​	缺点：索引无序，无法做范围查询，仅可做等值查询

### 有序数组

​	优点：可做等值查询和范围查询

​	缺点：插入新数据效率低，仅适用于静态存储引擎

### 二叉树

​	优点：搜索效率最高

​	缺点：索引会存储到磁盘中，如果树太深，访问磁盘的次数就变多。

​	改进：为了让一个查询尽量少地读磁盘， 就必须让查询过程访问尽量少的数据块。 那么， 我们就不应该

使用二叉树， 而是要使用“N叉”树。 这里， “N叉”树中的“N”取决于数据块的大小 。

>待查询:
>
>1. 二叉搜索树
>2. 跳表
>3. LSM树

## InnoDB的索引模型

B+树，每一个索引对应一个B+树。**B+树能够很好地配合磁盘的读写特性， 减少单次查询的磁盘访问次数。**  

InnoDB是索引组织表， **一般情况下需要创建一个自增主键， 这样非主键索引占用的空间最小。** 

>1）B-Tree
>
>在看B+Tree之前，我们先看看B-Tree
>
>B-Tree是一种为外查找（磁盘类外存储设备，数据量太大不能全放在内存里）而设计的平衡多叉树。那为什么用B树而不用其他的如二叉树、平衡二叉树呢？
>
>原因在于当存储关键字个数确定后，用B树进行存储所需要的最大树高相对于二叉树、平衡二叉树要小。这能够减小IO次数，从而提高检索效率。换句话说，使用B树能够确保，访问到任意数据的IO请求的最大次数是确定的。
>
>2）B+Tree
>
>所谓的B+Tree和B-Tree的区别仅仅在于，B-Tree的所有节点均用于存储键或者值。而B+Tree只有叶子节点才用于存储数据，而非叶子节点用于存储键。
>
>B+Tree是对B-Tree的一种优化。因为当非叶子节点存储的值占位太多时，便会增加树的高度。树高的增加带来的是IO的增加。

### 索引类型

​	主键索引（聚簇索引（clustered index） ），主键索引的叶子节点存的是整行数据  

​	非主键索引（二级索引），非主键索引的叶子节点内容是主键的值  

### 基于主键索引与普通索引的区别是什么？

如果语句是select * from T where ID=500， 即主键查询方式， 则只需要搜索ID这棵B+树；
如果语句是select * from T where k=5， 即普通索引查询方式， 则需要先搜索k索引树， 得到ID
的值为500， 再到ID索引树搜索一次。 这个过程称为回表。



也就是说， 基于非主键索引的查询需要多扫描一棵索引树。 因此， 我们在应用中**应该尽量使用主**
**键查询**  

## 索引维护

### 页分裂（会降低性能和空间效率）

R5所在的数据页已经满了， 根据B+树的算法， 这时候需要申请一个新的数据页， 然后挪动部分数据过去。 这个过程称为页分裂。

 除了性能外， 页分裂操作还影响数据页的利用率。 原本放在一个页的数据， 现在分到两个页中，整体空间利用率降低大约50%。  

### 哪些场景下应当使用自增主键

1. 递增插入的场景

>如果是业务逻辑的字段做主键，不可保证有序插入。成本较高
>
>除了考虑性能外， 我们还可以从存储空间的角度来看。 假设你的表中确实有一个唯一字段， 比如
>字符串类型的身份证号， 那应该用身份证号做主键， 还是用自增字段做主键呢？
>
>由于每个非主键索引的叶子节点上都是主键的值。 如果用身份证号做主键， 那么每个二级索引的
>叶子节点占用约20个字节， 而如果用整型做主键， 则只要4个字节， 如果是长整型（bigint） 则是
>8个字节。  
>
>显然， 主键长度越小， 普通索引的叶子节点就越小， 普通索引占用的空间也就越小。
>所以， 从性能和存储空间方面考量， 自增主键往往是更合理的选择  

### 有没有什么场景适合用业务字段直接做主键的呢？  （KV场景）

1. 只有一个索引；
2. 该索引必须是唯一索引。  

*直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树*  



## 问题4.1：重建索引k和重建主键索引是否合理？

1. 重建索引k

```sql
alter table T drop index k;
alter table T add index(k);
```

2. 重建主键索引

```sql
alter table T drop primary key;
alter table T add promary key(id);
```

对于上面这两个重建索引的做法，说出你的理解。

如果有不合适的，为什么？更好的方法是什么？

>解答：
>
>背景知识：为什么需要重建索引？
>
>索引可能因为删除，或者页分裂等原因，导致数据页有空洞，重建索引的过程会创建一个新的索引，把数据俺顺序插入，这样页面的利用率更高，也就是索引更紧凑，更省空间。
>
>参考答案：
>
>重建索引k的做法是合理的，可以达到省空间的目的。
>
>重建主键的过程不合理。因为不论是删除主键还是创建主键，都会将整个表重建。所以连着执行重建索引k+重建主键这两个语句的话，第一个语句就白做了。
>
>这两个语句，**可以用下面这个语句代替：**
>
>```sql
>alter table T engine = InnoDB;
>```



## 什么是回表和覆盖索引？

### 回表

问题：在表T中，如果执行下面这条语句，需要执行几次树的搜索操作，会扫描多少行？

```sql
select *from T where k between 3 and 5;
```

建表语句：

```sql
mysql>create table T (
	ID int primary key,
    k int NOT NULL DEFAULT 0,
    s varchar(16) NOT NULL DEFAULT '',
    index k(k))
    engine = InnoDB;
    insert into T value(100,1,'aa'),(200,2,'bb'),(300,3,'cc'),(400,4,'dd'),(500,5,'ee'),(600,6,'ff'),(700,7,'gg');

```

[![cyXtk4.png](https://z3.ax1x.com/2021/04/14/cyXtk4.png)](https://imgtu.com/i/cyXtk4)

select查询语句的执行流程

>1. 在k索引树上找到k = 3 的记录，取得ID = 3；
>2. 再到ID索引树查到ID=300对应的R3；（回表）
>3. 在k索引树取下一个值k = 5,取得ID=500；
>4. 再回到ID索引树查到ID = 500对应的R4；（回表）
>5. 在k索引树取下一个值k = 6，不满足条件，循环结束

在这个过程中，回到主键索引树搜索的过程，称为回表。

### 覆盖索引（索引优化，避免回表过程）

概念：如果把上面的查询语句换成

```sql
select ID from T where k between 3 and 5;
```

这时只需要查ID的值，而ID的值已经在K索引树上了，因此可以直接提供查询的结果，不需要回表。也就是说，在这个查询里面，索引k已经“覆盖了”我们的查询需求，我们称为覆盖索引。

**索引覆盖可以减少树的搜索次数，显著提升查询性能，是一个常用的性能优化手段。**



> 优质博客：[如何避免回表查询？什么是索引覆盖？ | 1分钟MySQL优化系列](https://mp.weixin.qq.com/s/y0pjtNUZhOW2ZBOy4m-xsA)



## 最左前缀原则

**B+ 树这种索引结构，可以利用索引的“最左前缀”，来定位记录**  



通过实例理解**单列索引、多列索引以及最左前缀原则**

实例：现在我们想查出满足以下条件的用户id：

```sql
SELECT ｀uid｀ FROM people WHERE lname｀=’Liu’ AND ｀fname｀=’Zhiqun’ AND ｀age｀=26
```


因为我们不想扫描整表，故考虑用索引。

1.**单列索引：**

```sql
ALTER TABLE people ADD INDEX lname (lname);
```


将lname列建索引，这样就把范围限制在lname=’Liu’的结果集1上，之后扫描结果集1，产生满足fname=’Zhiqun’的结果集2，再扫描结果集2，找到 age=26的结果集3，即最终结果。

由于建立了lname列的索引，与执行表的完全扫描相比，效率提高了很多，但我们要求扫描的记录数量仍旧远远超过了实际所需 要的。虽然我们可以删除lname列上的索引，再创建fname或者age 列的索引，但是，不论在哪个列上创建索引搜索效率仍旧相似。

**2.多列索引：**

```sql
ALTER TABLE people ADD INDEX lname_fname_age (lame,fname,age);
```


为了提高搜索效率，我们需要考虑运用多列索引,由于索引文件以B－Tree格式保存，所以我们不用扫描任何记录，即可得到最终结果。

**注：在mysql中执行查询时，只能使用一个索引，如果我们在lname,fname,age上分别建索引,执行查询时，只能使用一个索引，mysql会选择一个最严格(获得结果集记录数最少)的索引。**

**3.最左前缀：**

顾名思义，就是最左优先，上例中我们创建了lname_fname_age多列索引,相当于创建了(lname)单列索引，(lname,fname)组合索引以及(lname,fname,age)组合索引。

**注：在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。**



> 最左前缀原则:
>
> 当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。



## 索引下推

问题引出：满足最左前缀原则的时候，最左前缀可以用于在索引中定位记录。这时，你
可能要问，那些不符合最左前缀的部分，会怎么样呢？  

答：

在 MySQL 5.6 之前，只能从 ID3 开始一个个回表。到主键索引上找出数据行，再对比字段
值。
而 MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过
程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。  

[![c6PcAx.png](https://z3.ax1x.com/2021/04/14/c6PcAx.png)](https://imgtu.com/i/c6PcAx)

[![c6PbUP.png](https://z3.ax1x.com/2021/04/14/c6PbUP.png)](https://imgtu.com/i/c6PbUP)

途中的虚线箭头表示回表一次。

在索引下推可以减少回表的次数。



## 问题4.2

实际上主键索引也是可以使用多个字段的。DBA 小吕在入职新公司的时候，就发现自己接
手维护的库里面，有这么一个表，表结构定义类似这样的：  

```sql
CREATE TABLE `geek` (
  `a` int NOT NULL,
  `b` int NOT NULL,
  `c` int NOT NULL,
  `d` int NOT NULL,
  PRIMARY KEY (`a`,`b`),
  KEY `c` (`c`),
  KEY `ca` (`c`,`a`)
  KEY `cb` (`c`,`b`)
) ENGINE=InnoDB;
```

公司的同事告诉他说，由于历史原因，这个表需要 a、b 做联合主键，这个小吕理解了。

但是，既然主键包含了 a、b 这两个字段，那意味着单独在字段 c 上创建一个索引，就已经包含了三个字段了呀，为什么要创建“ca”“cb”这两个索引？  

同事告诉他，是因为他们的业务里面有这样的两种语句：  

```sql
select * from geek where c=N order by a limit 1;
select * from geek where c=N order by b limit 1;
```

我给你的问题是，这位同事的解释对吗，为了这两个查询模式，这两个索引是否都是必须
的？为什么呢？  

**解答：**

>表记录：
>
>1.主键a,b的聚簇索引组织顺序相当于order by a,b，也就是先按a排序，再按b排序，c无序
>
>|  a   |  b   |  c   |  d   |
>| :--: | :--: | :--: | :--: |
>|  1   |  2   |  3   |  d   |
>|  1   |  3   |  2   |  d   |
>|  1   |  4   |  3   |  d   |
>|  2   |  1   |  3   |  d   |
>|  2   |  2   |  2   |  d   |
>|  2   |  3   |  4   |  d   |
>
>2.索引 ca 的组织是先按 c 排序，再按 a 排序，同时记录主键  
>
>|  c   |  a   | 主键部分b（注意这里只有b，而不是ab） |
>| :--: | :--: | :----------------------------------: |
>|  2   |  1   |                  3                   |
>|  2   |  2   |                  2                   |
>|  3   |  1   |                  2                   |
>|  3   |  1   |                  4                   |
>|  3   |  2   |                  1                   |
>|  4   |  2   |                  3                   |
>
>这个索引c的数据是一模一样的。
>
>3.索引 ca 的组织是先按 c 排序，再按 a 排序，同时记录主键  
>
>|  c   |  b   | 主键部分a（注意这里只有a） |
>| :--: | :--: | :------------------------: |
>|  2   |  2   |             2              |
>|  2   |  3   |             1              |
>|  3   |  1   |             2              |
>|  3   |  2   |             1              |
>|  3   |  4   |             1              |
>|  4   |  3   |             2              |
>
>与索引c的数据不一样。
>
>所以结论是，索引ca可以去掉，cb需要保留。



