# 一、MYSQL的基础架构

[![c04czn.png](https://z3.ax1x.com/2021/04/11/c04czn.png)](https://imgtu.com/i/c04czn)







# 四、索引

## 索引的常见类型

### 哈希表

​	优点：插入新数据会很快

​	缺点：索引无序，无法做范围查询，仅可做等值查询

### 有序数组

​	优点：可做等值查询和范围查询

​	缺点：插入新数据效率低，仅适用于静态存储引擎

### 二叉树

​	优点：搜索效率最高

​	缺点：索引会存储到磁盘中，如果树太深，访问磁盘的次数就变多。

​	改进：为了让一个查询尽量少地读磁盘， 就必须让查询过程访问尽量少的数据块。 那么， 我们就不应该

使用二叉树， 而是要使用“N叉”树。 这里， “N叉”树中的“N”取决于数据块的大小 。

>待查询:
>
>1. 二叉搜索树
>2. 跳表
>3. LSM树

## InnoDB的索引模型

B+树，每一个索引对应一个B+树。**B+树能够很好地配合磁盘的读写特性， 减少单次查询的磁盘访问次数。**  

InnoDB是索引组织表， **一般情况下需要创建一个自增主键， 这样非主键索引占用的空间最小。** 

>1）B-Tree
>
>在看B+Tree之前，我们先看看B-Tree
>
>B-Tree是一种为外查找（磁盘类外存储设备，数据量太大不能全放在内存里）而设计的平衡多叉树。那为什么用B树而不用其他的如二叉树、平衡二叉树呢？
>
>原因在于当存储关键字个数确定后，用B树进行存储所需要的最大树高相对于二叉树、平衡二叉树要小。这能够减小IO次数，从而提高检索效率。换句话说，使用B树能够确保，访问到任意数据的IO请求的最大次数是确定的。
>
>2）B+Tree
>
>所谓的B+Tree和B-Tree的区别仅仅在于，B-Tree的所有节点均用于存储键或者值。而B+Tree只有叶子节点才用于存储数据，而非叶子节点用于存储键。
>
>B+Tree是对B-Tree的一种优化。因为当非叶子节点存储的值占位太多时，便会增加树的高度。树高的增加带来的是IO的增加。

### 索引类型

​	主键索引（聚簇索引（clustered index） ），主键索引的叶子节点存的是整行数据  

​	非主键索引（二级索引），非主键索引的叶子节点内容是主键的值  

### 基于主键索引与普通索引的区别是什么？

如果语句是select * from T where ID=500， 即主键查询方式， 则只需要搜索ID这棵B+树；
如果语句是select * from T where k=5， 即普通索引查询方式， 则需要先搜索k索引树， 得到ID
的值为500， 再到ID索引树搜索一次。 这个过程称为回表。



也就是说， 基于非主键索引的查询需要多扫描一棵索引树。 因此， 我们在应用中**应该尽量使用主**
**键查询**  

## 索引维护

### 页分裂（会降低性能和空间效率）

R5所在的数据页已经满了， 根据B+树的算法， 这时候需要申请一个新的数据页， 然后挪动部分数据过去。 这个过程称为页分裂。

 除了性能外， 页分裂操作还影响数据页的利用率。 原本放在一个页的数据， 现在分到两个页中，整体空间利用率降低大约50%。  

### 哪些场景下应当使用自增主键

1. 递增插入的场景

>如果是业务逻辑的字段做主键，不可保证有序插入。成本较高
>
>除了考虑性能外， 我们还可以从存储空间的角度来看。 假设你的表中确实有一个唯一字段， 比如
>字符串类型的身份证号， 那应该用身份证号做主键， 还是用自增字段做主键呢？
>
>由于每个非主键索引的叶子节点上都是主键的值。 如果用身份证号做主键， 那么每个二级索引的
>叶子节点占用约20个字节， 而如果用整型做主键， 则只要4个字节， 如果是长整型（bigint） 则是
>8个字节。  
>
>显然， 主键长度越小， 普通索引的叶子节点就越小， 普通索引占用的空间也就越小。
>所以， 从性能和存储空间方面考量， 自增主键往往是更合理的选择  

### 有没有什么场景适合用业务字段直接做主键的呢？  （KV场景）

1. 只有一个索引；
2. 该索引必须是唯一索引。  

*直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树*  



## 问题4.1：重建索引k和重建主键索引是否合理？

1. 重建索引k

```sql
alter table T drop index k;
alter table T add index(k);
```

2. 重建主键索引

```sql
alter table T drop primary key;
alter table T add promary key(id);
```

对于上面这两个重建索引的做法，说出你的理解。

如果有不合适的，为什么？更好的方法是什么？

>解答：
>
>背景知识：为什么需要重建索引？
>
>索引可能因为删除，或者页分裂等原因，导致数据页有空洞，重建索引的过程会创建一个新的索引，把数据俺顺序插入，这样页面的利用率更高，也就是索引更紧凑，更省空间。
>
>参考答案：
>
>重建索引k的做法是合理的，可以达到省空间的目的。
>
>重建主键的过程不合理。因为不论是删除主键还是创建主键，都会将整个表重建。所以连着执行重建索引k+重建主键这两个语句的话，第一个语句就白做了。
>
>这两个语句，**可以用下面这个语句代替：**
>
>```sql
>alter table T engine = InnoDB;
>```



## 什么是回表和覆盖索引？

### 回表

问题：在表T中，如果执行下面这条语句，需要执行几次树的搜索操作，会扫描多少行？

```sql
select *from T where k between 3 and 5;
```

建表语句：

```sql
mysql>create table T (
	ID int primary key,
    k int NOT NULL DEFAULT 0,
    s varchar(16) NOT NULL DEFAULT '',
    index k(k))
    engine = InnoDB;
    insert into T value(100,1,'aa'),(200,2,'bb'),(300,3,'cc'),(400,4,'dd'),(500,5,'ee'),(600,6,'ff'),(700,7,'gg');

```

[![cyXtk4.png](https://z3.ax1x.com/2021/04/14/cyXtk4.png)](https://imgtu.com/i/cyXtk4)

select查询语句的执行流程

>1. 在k索引树上找到k = 3 的记录，取得ID = 3；
>2. 再到ID索引树查到ID=300对应的R3；（回表）
>3. 在k索引树取下一个值k = 5,取得ID=500；
>4. 再回到ID索引树查到ID = 500对应的R4；（回表）
>5. 在k索引树取下一个值k = 6，不满足条件，循环结束

在这个过程中，回到主键索引树搜索的过程，称为回表。

### 覆盖索引（索引优化，避免回表过程）

概念：如果把上面的查询语句换成

```sql
select ID from T where k between 3 and 5;
```

这时只需要查ID的值，而ID的值已经在K索引树上了，因此可以直接提供查询的结果，不需要回表。也就是说，在这个查询里面，索引k已经“覆盖了”我们的查询需求，我们称为覆盖索引。

**索引覆盖可以减少树的搜索次数，显著提升查询性能，是一个常用的性能优化手段。**



> 优质博客：[如何避免回表查询？什么是索引覆盖？ | 1分钟MySQL优化系列](https://mp.weixin.qq.com/s/y0pjtNUZhOW2ZBOy4m-xsA)



## 最左前缀原则

**B+ 树这种索引结构，可以利用索引的“最左前缀”，来定位记录**  



通过实例理解**单列索引、多列索引以及最左前缀原则**

实例：现在我们想查出满足以下条件的用户id：

```sql
SELECT ｀uid｀ FROM people WHERE lname｀=’Liu’ AND ｀fname｀=’Zhiqun’ AND ｀age｀=26
```


因为我们不想扫描整表，故考虑用索引。

1.**单列索引：**

```sql
ALTER TABLE people ADD INDEX lname (lname);
```


将lname列建索引，这样就把范围限制在lname=’Liu’的结果集1上，之后扫描结果集1，产生满足fname=’Zhiqun’的结果集2，再扫描结果集2，找到 age=26的结果集3，即最终结果。

由于建立了lname列的索引，与执行表的完全扫描相比，效率提高了很多，但我们要求扫描的记录数量仍旧远远超过了实际所需 要的。虽然我们可以删除lname列上的索引，再创建fname或者age 列的索引，但是，不论在哪个列上创建索引搜索效率仍旧相似。

**2.多列索引：**

```sql
ALTER TABLE people ADD INDEX lname_fname_age (lame,fname,age);
```


为了提高搜索效率，我们需要考虑运用多列索引,由于索引文件以B－Tree格式保存，所以我们不用扫描任何记录，即可得到最终结果。

**注：在mysql中执行查询时，只能使用一个索引，如果我们在lname,fname,age上分别建索引,执行查询时，只能使用一个索引，mysql会选择一个最严格(获得结果集记录数最少)的索引。**

**3.最左前缀：**

顾名思义，就是最左优先，上例中我们创建了lname_fname_age多列索引,相当于创建了(lname)单列索引，(lname,fname)组合索引以及(lname,fname,age)组合索引。

**注：在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。**



> 最左前缀原则:
>
> 当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。



## 索引下推

问题引出：满足最左前缀原则的时候，最左前缀可以用于在索引中定位记录。这时，你
可能要问，那些不符合最左前缀的部分，会怎么样呢？  

答：

在 MySQL 5.6 之前，只能从 ID3 开始一个个回表。到主键索引上找出数据行，再对比字段
值。
而 MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过
程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。  

[![c6PcAx.png](https://z3.ax1x.com/2021/04/14/c6PcAx.png)](https://imgtu.com/i/c6PcAx)

[![c6PbUP.png](https://z3.ax1x.com/2021/04/14/c6PbUP.png)](https://imgtu.com/i/c6PbUP)

途中的虚线箭头表示回表一次。

在索引下推可以减少回表的次数。



## 问题4.2

实际上主键索引也是可以使用多个字段的。DBA 小吕在入职新公司的时候，就发现自己接
手维护的库里面，有这么一个表，表结构定义类似这样的：  

```sql
CREATE TABLE `geek` (
  `a` int NOT NULL,
  `b` int NOT NULL,
  `c` int NOT NULL,
  `d` int NOT NULL,
  PRIMARY KEY (`a`,`b`),
  KEY `c` (`c`),
  KEY `ca` (`c`,`a`)
  KEY `cb` (`c`,`b`)
) ENGINE=InnoDB;
```

公司的同事告诉他说，由于历史原因，这个表需要 a、b 做联合主键，这个小吕理解了。

但是，既然主键包含了 a、b 这两个字段，那意味着单独在字段 c 上创建一个索引，就已经包含了三个字段了呀，为什么要创建“ca”“cb”这两个索引？  

同事告诉他，是因为他们的业务里面有这样的两种语句：  

```sql
select * from geek where c=N order by a limit 1;
select * from geek where c=N order by b limit 1;
```

我给你的问题是，这位同事的解释对吗，为了这两个查询模式，这两个索引是否都是必须
的？为什么呢？  

**解答：**

>表记录：
>
>1.主键a,b的聚簇索引组织顺序相当于order by a,b，也就是先按a排序，再按b排序，c无序
>
>|  a   |  b   |  c   |  d   |
>| :--: | :--: | :--: | :--: |
>|  1   |  2   |  3   |  d   |
>|  1   |  3   |  2   |  d   |
>|  1   |  4   |  3   |  d   |
>|  2   |  1   |  3   |  d   |
>|  2   |  2   |  2   |  d   |
>|  2   |  3   |  4   |  d   |
>
>2.索引 ca 的组织是先按 c 排序，再按 a 排序，同时记录主键  
>
>|  c   |  a   | 主键部分b（注意这里只有b，而不是ab） |
>| :--: | :--: | :----------------------------------: |
>|  2   |  1   |                  3                   |
>|  2   |  2   |                  2                   |
>|  3   |  1   |                  2                   |
>|  3   |  1   |                  4                   |
>|  3   |  2   |                  1                   |
>|  4   |  2   |                  3                   |
>
>这个索引c的数据是一模一样的。
>
>3.索引 ca 的组织是先按 c 排序，再按 a 排序，同时记录主键  
>
>|  c   |  b   | 主键部分a（注意这里只有a） |
>| :--: | :--: | :------------------------: |
>|  2   |  2   |             2              |
>|  2   |  3   |             1              |
>|  3   |  1   |             2              |
>|  3   |  2   |             1              |
>|  3   |  4   |             1              |
>|  4   |  3   |             2              |
>
>与索引c的数据不一样。
>
>所以结论是，索引ca可以去掉，cb需要保留。



# 五、锁(全局锁、表级锁、行锁)

## 1.全局锁

### ①概念

全局锁就是对整个数据库实例加锁。

MySQL加全局锁的方法：Flush tables with read lock(FTWRL)。

当你需要让**整个库处于只读状态的时候**，可以使用这个命令，之后其他的线程的以下语句会被阻塞：

- 数据更新语句（数据的增删改）
- 数据定义语句（包括建表、修改表结构等）
- 更新类事务的提交语句

>**数据库：**
>
>数据库是文件的集合，是依照某种数据模型组织起来并存放于二级存储器中的数据集合；存放在磁盘中。
>
>**数据库实例：**
>
>数据库实例是程序，是位于用户和操作系统之间的一层数据管理软件，用户对数据库中的数据做任何的操作，包括数据定义、数据查询、数据维护、数据库运行控制等等都是在数据库实例下进行的，应用程序只有通过数据库实例才能和数据库打交道(因为数据库是存放在磁盘里的，程序不能直接读取磁盘中的文件，只能通过将数据库读取到内存中，才可以对数据库中的数据进行操作)。

### ②使用场景

做全库逻辑备份。即把整库每个表都select出来存成文本。

### ③弊端

全局锁让整库都只读，存在以下的风险：

- 如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；
- 如果在从库上备份，那么备份期间从库不能执行主库同步过来的[binlog](https://www.cnblogs.com/rickiyang/p/13841811.html)，会导致主从延迟。

>MySQL 的 Binlog 日志是一种二进制格式的日志，Binlog 记录所有的 DDL 和 DML 语句(除了数据查询语句SELECT、SHOW等)，以 Event 的形式记录，同时记录语句执行时间。
>
>Binlog 的主要作用有两个：
>
>1. 数据恢复
>
>   因为 Binlog 详细记录了所有修改数据的 SQL，当某一时刻的数据误操作而导致出问题，或者数据库宕机数据丢失，那么可以根据 Binlog 来回放历史数据。
>
>2. [主从复制](https://www.cnblogs.com/rickiyang/p/13856388.html)
>
>   想要做多机备份的业务，可以去监听当前写库的 Binlog 日志，同步写库的所有更改。
>
>Binlog 包括两类文件：
>
>- 二进制日志索引文件(.index)：记录所有的二进制文件。
>- 二进制日志文件(.00000*)：记录所有 DDL 和 DML 语句事件。



### 问题1：备份为什么要加锁？

因为如果不加锁的话，备份系统备份的得到的库不是一个逻辑时间点，这个视图是逻辑不一致的。

>如何拿到一致性视图？
>
>就是在可重复读隔离级别下开启一个事务。

官方自带的逻辑备份工具是 mysqldump。**当 mysqldump 使用参数–single-transaction**
**的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。**而由于 MVCC 的支持，
这个过程中数据是可以正常更新的  

### 问题2：有逻辑备份工具mysqldump实现一致性读取，那为什么还需要使用FTWRL命令呢？

有的引擎并不支持可重复读这个隔离级别，比如MylSAM这种不支持事务的引擎，如果备份过程中有更新，总是只能取到最新的数据，那么就破坏了备份的一致性。

这时，我们就需要使用FTWRL命令了。

---

所以，**single-transaction 方法只适用于所有的表使用事务引擎的库。**如果有的表使用了
不支持事务的引擎，那么备份就只能通过 FTWRL 方法。  

### 问题3:既然要全库只读，为什么不使用set global readonly = true的方式呢？而是建议使用FTWRL方式呢？

- 在有些系统中，readonly的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改global变量的方法影响面更大。
- 在异常处理机制上有差异。如果执行FTWRL命令之后，由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设为readonly之后，如果客户端发生异常，则数据库就会一直保持readonly状态，这样会导致整个库长时间处于不可写的状态，风险较高。



---

业务的更新不止是增删改数据（DML），还有可能是加字段等修改表结构的操作（DDL）。无论是哪种方法，一个库被全局锁上以后，如果想要对里面任何一个表做加字段的操作，都是会被锁住的。





## 2.表级锁

MySQL里面表级别的锁有两种：

- 表锁
- 元数据锁（metadata lock ，MDL）

### 表锁

与FTWRL类似，可以用unlock tables 主动释放锁，也可以在客户端断开的时候自动释放。

需要注意的是，lock table语法出了会限制别的线程的读写外，也限定了本线程接下来的操作对象。

```mysql
lock table t1 read,t2 write;
```

>如果在某个线程A中执行了上面这条语句，则其他线程写t1，读写t2的语句都会被阻塞。
>
>同时，线程A在执行unlock tables之前，也只能执行读t1，读写t2的操作。
>
>连写t1都不允许，自然也不能访问其他表。

在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于 **InnoDB 这种支持行锁的引擎，一般不使用 lock tables 命令来控制并发**，毕竟锁住整个表的影响面还是太大  

### 元数据锁（MDL）(保证读写的正确性)

***MDL 不需要显式使用，在访问一个表的时候会被自动加上。***  

在 MySQL 5.5 版本中引入了 MDL，当对一个表做增删改查操作的时候，加 MDL读锁；当要对表做结构变更操作的时候，加 MDL 写锁  。

- 读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。  
- 读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行  



#### 问题1：MDL锁是系统默认会加的，这种机制可能存在哪些问题呢？

> 1. 给一个表加字段，或者修改字段，或者加索引，都需要扫描全表的数据。
>
> 2. 所有对表的增删改查操作都需要先申请MDL读锁

![MDL锁.PNG](https://github.com/ZEQINLIN-666/MyNotes/blob/main/image/MDL%E9%94%81.PNG?raw=true)

- session A 先启动，这时候表t会加一个MDL读锁。由于session B需要的也是MDL读锁。因此可以正常执行
- 而session C会被阻塞。是因为session A的MDL读锁还没有释放，而session C需要MDL写锁，因此只能被阻塞。
- 然后，如果只有session C自己被阻塞那还没有什么关系，但是之后所有要在表t上申请MDL读锁的请求也会被session C阻塞。因为所有对表的增删改查操作都需要先申请MDL读锁，就都被锁住，等于当前打这个表完全不可读写了。
- 如果某个表上的查询语句频繁，而且客户端有重试机制。也就是说超时后会再起一个新session再进行请求的话，这个库的线程很快就会爆满。

---

**事务中的MDL锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而是会等到整个事务提交后再释放。**



#### 问题2：如何安全的给小表加字段

首先要解决长事务，如果长事务不提交，就会一直占着MDL锁。在MySQL的information_schmea表的innodb_trx表中，可以查到当前执行中的事务。如果要做DDL变更的表刚搞有长事务在执行，要考虑先暂停DDL，或者kill掉这个长事务。



#### 问题3：如果要变更的表示一个热点表，虽然数据量不大，但是上面的请求很频繁，而你不得不加个字段，该怎么做？

这时候kill可能未必管用，因为新的请求马上就来了。

比较理想的机制是，在alter table语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到MDL写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后再通过重试命令重复这个过程。

>MariaDB已经合并了AliSQL的这个功能，所以这两个开源分支目前都支持DDL NOWAIT/WAIT  n 这个语法。
>
>```mysql
>alter table tbl_name NOWAIT add column ...
>alter table tbl_name WAIT N add column ...
>```
>
>

---

## 小结  MySQL 的全局锁和表级锁。

全局锁主要用在逻辑备份过程中。**对于全部是 InnoDB 引擎的库，我建议你选择使用-single-transaction 参数(实现一致性读取)，**对应用会更友好。

**表锁一般是在数据库引擎不支持行锁的时候才会被用到的。**如果你发现你的应用程序里有lock tables 这样的语句，你需要追查一下，比较可能的情况是：

- 要么是你的系统现在还在用 MyISAM 这类不支持事务的引擎，那要安排升级换引擎；
- 要么是你的引擎升级了，但是代码还没升级。我见过这样的情况，最后业务开发就是把lock tables 和 unlock tables 改成 begin 和 commit，问题就解决了。

MDL 会直到事务提交才释放，在做表结构变更的时候，你一定要小心不要导致锁住线上查询和更新。  

## 问题5.1

备份一般都会在备库上执行，在用-single-transaction方法做逻辑备份的过程中，如果主库上的一个小表做了一个DDL，比如给一个表上加了一列。这时候，从备库上会看到什么现象呢？

即当备库用-single-transaction做逻辑备份的时候，如果从库的binlog传来了一个DDL语句会怎么样？

#### 解答：

假设这个 DDL 是针对表 t1 的， 备份过程中几个关键的语句如下：

```mysql
Q1:SET SESSION TRANSACTION ISOLATION LEVEL REPEATBALE READ;
Q2:START TRANSACTION WITH CONSISTENT SNAPSHOT;
/*other tables*/
Q3:SAVEPOINT sp;
/*时刻 1*/
Q4:show create table `t1`;
/*时刻 2*/
Q5:SELECT *FROM `t1`;
/*时刻 3*/
Q6:ROLLBACK TO SAVEPOINT sp；
/*时刻 4*/
/*other tables*/
```

- 在备份开始的时候，为了确保RR（可重复读）隔离级别，在设置一次RR隔离级别（Q1）；、
- 启动事务，这里用WITH CONSISTENT SNAPSHOT 确保这个语句执行完可以得到一个一致性视图（Q2）
- **设置一个保存点**（Q3）
- show create是为了拿到表结构（Q4）,然后正式导数据（Q5）,回滚到SAVEPOINT sp，在这里的作用是释放t1的MDL锁（Q6）

DDL从主库传过来的时间按照效果不同，可以分为四个时刻。

1. 如果在Q4语句执行之前到达，现象：没有影响，备份拿到的是DDL后的表结构
2. 如果是在“时刻2“到达，则表结构被改过，Q5执行的时候，会报`Table definition has changed,please retry transaction`，现象：mysqldump终止。
3. 如果是在“时刻2”和“时刻3”之间到达，mysqldump占着t1的MDL读锁，binlog被阻塞。现象：主从延迟，知道Q6执行完成。
4. 从“时刻4”开始，mysqldump释放了MDL锁。现象：没有影响，备份拿到的是DDL前的表结构。

## 3.行锁

MySQL的行锁是在引擎层的各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如MyISAM引擎就不支持行锁。

不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。  

**那么要如何通过行锁和减少锁冲突来提升业务的并发度呢？**

### 两阶段锁

#### 问题1：在下面的操作序列中，事务 B 的 update 语句执行时会是什么现象呢？假设字段 id 是表 t 的主键 ？

![两阶段锁.PNG](https://github.com/ZEQINLIN-666/MyNotes/blob/main/image/%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81.PNG?raw=true)

解答：

因为事务A持有的两个记录的行锁，都是在commit的时候才释放的，所以事务B的update语句会被阻塞，直到事务A执行commit之后，事务B才能继续执行。

---

**在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。**



在直到两阶段锁协议的设定后，在实际的应用中。如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。

>假设你负责实现一个电影票在线交易业务，顾客 A 要在影院 B 购买电影票。我们简化一
>点，这个业务需要涉及到以下操作：
>
>1. 从顾客 A 账户余额中扣除电影票价；
>2. **给影院 B 的账户余额增加这张电影票价;**
>3. 记录一条交易日志
>
>也就是说，要完成这个交易，我们需要 update 两条记录，并 insert 一条记录。当然，为了保证交易的原子性，我们要把这三个操作放在一个事务中。那么，你会怎样安排这三个语句在事务中的顺序呢？  
>
>试想如果同时有另外一个顾客 C 要在影院 B 买票，那么这两个事务冲突的部分就是语句 2了。因为它们要更新同一个影院账户的余额，需要修改同一行数据。
>
>根据两阶段锁协议，不论你怎样安排语句顺序，所有的操作需要的行锁都是在事务提交的时候才释放的。所以，如果你把语句 2 安排在最后，比如按照 3、1、2 这样的顺序，那么影院账户余额这一行的锁时间就最少。这就最大程度地减少了事务之间的锁等待，提升了并发度.  



### 死锁与死锁检测

#### 概念引出：

如果这个影院做活动，可以低价预售一年内所有的电影票，而且这个活动只做一天。于是在活动时间开始的时候，你的 MySQL 就挂了。你登上服务器一看，CPU 消耗接近 100%，但整个数据库每秒就执行不到 100 个事务。这是什么原因呢？  



**在并发系统中，不同线程出现了循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无线等待的状态，称为死锁。**

![死锁业务.PNG](https://github.com/ZEQINLIN-666/MyNotes/blob/main/image/%E6%AD%BB%E9%94%81%E4%B8%9A%E5%8A%A1.PNG?raw=true)

这时候，事务 A 在等待事务 B 释放 id=2 的行锁，而事务 B 在等待事务 A 释放 id=1 的行锁。 事务 A 和事务 B 在互相等待对方的资源释放，就是进入了死锁状态。当出现死锁以后，有两种策略：

1.  直接进入等待，直到超时。这个超时时间可以通过参数`innodb_lock_wait_timeout`来设置。
2. 发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on，表示开启是这个逻辑。

**关于第一个策略：**

在InnoDB中，innodb_lock_wait_timeout 的默认值是50s，意味着如果采用第一个策略，当出现死锁以后，第一个被锁住的线程要过50s才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的。

但是我们有不能把这个时间设置成一个很小的值，比如1s。

这样当出现死锁的时候，确实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，超时时间设置太短的话，会出现很多误伤。

**关于第二个策略：**

主动死锁检测，innodb_deadlock_detect的默认值是on。主动死锁检测发生在死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的，比如时间性能消耗，死锁检测要耗费大量的CPU资源。



#### 问题2：主动死锁检测可以有效地预防死锁，但是如果是在所有事物都要更新同一行的场景呢？

问题补充：

每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是 O(n) 的操作。假设有 1000 个并发线程要同时更新同一行，那么死锁检测操作就是100 万这个量级的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的 CPU 资源。因此，你就会看到 CPU 利用率很高，但是每秒却执行不了几个事务。  

**即：怎么解决由热点更新导致的性能问题呢？（问题的症结在于，死锁检测要耗费大量CPU资源**）

- **临时把死锁检测关掉。**

>但是这种操作本身带有一定的风险，因为业务涉及的时候一般不会把死锁当做一个严重错误，毕竟出现死锁了，就回滚，然后通过业务重试一般就没问题了，这是业务无损的。
>
>而关掉死锁检测意味着可能出现大量的超时，这是业务有损的。

- **控制并发度**

>如果并发能够控制住，比如同一行同时最多只有 10 个线程在更新，那么死锁检测的成本很低，就不会出现这个问题。  
>
>**那能否在客户端做并发控制呢？**
>
>答案是不能。因为客户端很多，假设有600个客户端，这样即使每个客户端控制到只有5个并发线程，汇总到数据库服务端之后，峰值并发数也可能要达到3000。
>
>**因此，这个并发控制要做在数据库服务端中。**
>
>也可以考虑在中间件实现；基本思路就是，对于同行的更新，在进入引擎之前排队，这样在InnoDB内部就不会有大量的死锁检测了（修改MySQL源码）
>
>如果无法再源码级别进行优化，那么能不能从设计上优化这个问题呢？
>
>**可以考虑通过将一行改成逻辑上的多行来减少锁冲突。**
>
>还是以影院账户为例，可以考虑放在多条记录上，比如 10 个记录，影院的账户总额等于这 10 个记录的值的总和。这样每次要给影院账户加金额的时候，随机选其中一条记录来加。这样每次冲突概率变成原来的1/10，可以减少锁等待个数，也就减少了死锁检测的 CPU 消耗。  
>
>这个方案看上去是无损的，但其实这类方案需要根据业务逻辑做详细设计。**如果账户余额可能会减少，比如退票逻辑，那么这时候就需要考虑当一部分行记录变成 0 的时候，代码要有特殊处理。**  

---

### 小结：

MySQL 的行锁，涉及了**两阶段锁协议、死锁和死锁检测**这两大部分内容。
以两阶段协议为起点，在开发的时候如何安排正确的事务语句。

**这里的原则 / 建议是：如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁的申请时机尽量往后放。**

但是，**调整语句顺序并不能完全避免死锁**。所以我们引入了死锁和死锁检测的概念，以及提供了三个方案，来减少死锁对数据库的影响。

减少死锁的主要方向，就是控制访问相同资源的并发事务量  



## 问题5.2

如果你要删除一个表里面的前 10000 行数据，有以下三种方法可以做到：  

1. 直接执行`delete from T limit 10000;`
2. **在一个连接中循环执行20次`delete from T limit 500;`**
3. 在20个连接中同时执行`delete from T limit 500;`

你会选择哪一种方法呢？为什么呢？

### 解答：

第二种方式相对较好。

第一种方式里面，单个语句占用时间长，锁的时间也比较长；而且大事务还会导致主从延迟。

第三种方式，会人为造成锁冲突。（开太多连接了）

## 六、InnoDB的事务和锁

### 问题引入:

在可重复读隔离级别，事务T启动的时候会创建一个视图read-view，之后事务T执行期间，即使有其他事务修改了数据，事务T看到的仍然跟在启动时看到的一样。也就是说，一个在可重复读隔离级别下执行的事务，好像不受外界影响。

但是，再行锁中方面，一个事务要更新一行，如果刚好有另外一个事务拥有这一行的行锁，就会被锁住，进入等待状态。

那么问题是：

`既然进入了等待状态，那么等到这个事务自己获取到行锁得更新数据的时候，它读到的值是什么呢？`

### 例子：

```mysql
CREATE TABLE `t` (
	`id` int(11) NOT NULL,
	`k` int(11) DEFAULT NULL,
	PRIMARY KEY (`id`)
) ENGINE=InnoDB;
insert into t(id, k) values(1,1),(2,2);
```

| 事务A                                       | 事务B                                                        | 事务C                              |
| ------------------------------------------- | ------------------------------------------------------------ | ---------------------------------- |
| start transaction with consistent snapshot; |                                                              |                                    |
|                                             | start transaction with consistent snapshot;                  |                                    |
|                                             |                                                              | update t set k = k+1 where id = 1; |
|                                             | update t set k = k + 1 where id = 1;             select k from t where id = 1; |                                    |
| select k from t where id = ; commit;        |                                                              |                                    |
|                                             | commit;                                                      |                                    |

>需要注意的是：
>
>- 事务的启动时机。
>
>`begin/start transaction `命令并不是一个事务的起点，在执行到它们之后的第一个操作InnoDB表的语句，事务才真正启动。（这种启动方式，一致性视图是在执行第一个快照读语句时创建的）
>
>如果想要马上启动一个事务，可以使用`start transaction with consistent snapshot`这个命令（这种启动方式，一致性视图是在执行该语句时创建的）
>
>- 默认autocommit = 1

在上面这个例子中。

- 事务C没有显式地使用begin/commit。表示这个update语句本身就是一个事务，语句完成的时候会自动提交。
- 事务B在更新了行之后查询
- 事务A在一个只读事务中查询，并且时间顺序上是在事务B的查询之后。

**这时，事务B查到的k的值是3，而事务A查到的K的值是1**。

---

请解释上面这种情况。

>在MySQL里，有两个“视图”的概念：
>
>1. 一个是 view。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是 create view … ，而它的查询方法与表一样  
>2. 另一个是 InnoDB 在实现 [MVCC](https://my.oschina.net/u/3944379/blog/4468822) 时用到的一致性读视图，即 consistent read view，用于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔离级别的实现  
>
>它没有物理结构，作用是事务执行期间用来定义“我能看到什么数据”  。

**“快照”在 MVCC 里是怎么工作的？**  

在可重复读隔离级别下，事务在启动的时候就“拍了个快照”。注意，这个快照是基于整库的 。但是，如果一个库有 100G，那么我启动一个事务，MySQL就要拷贝 100G 的数据出来，这个过程得多慢啊。可是，我平时的事务执行起来很快啊。如何解释这种现象呢？ 

**1.那么快照是怎么实现的？**

InnoDB 里面每个事务有一个唯一的事务 ID，叫作 transaction id。它是在事务开始的时候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的  。

而每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且把 transaction id 赋值给这个数据版本的事务 ID，记为 row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。

也就是说，数据表中的一行记录，其实可能有多个版本 (row)，每个版本有自己的 row trx_id。  

![行状态变更图.PNG](https://github.com/ZEQINLIN-666/MyNotes/blob/main/image/%E8%A1%8C%E7%8A%B6%E6%80%81%E5%8F%98%E6%9B%B4%E5%9B%BE.PNG?raw=true)

图中虚线框里是同一行数据的 4 个版本，当前最新版本是 V4，k 的值是 22，它是被transaction id 为 25 的事务更新的，因此它的 row trx_id 也是 25  



**2.语句的更新会生成undo log（回滚日志），那么在上面这个过程中，undo log在哪呢？**

- 实际上，图 2 中的三个虚线箭头，就是 undo log；而 V1、V2、V3 并不是物理上真实存在的，而是每次需要的时候根据当前版本和 undo log 计算出来的。比如，需要 V2 的时候，就是通过 V4 依次执行 U3、U2 算出来。  

**3.InnoDB是怎么定义那个“100G”的快照的？**

>可重复读的定义：一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见 。
>
>因此，一个事务只需要在启动的时候声明说，“以我启动的时刻为准，如果一个数据版本是在我启动之前生成的，就认；如果是我启动以后才生成的，我就不认，我必须要找到它的上一个版本”。
>当然，如果“上一个版本”也不可见，那就得继续往前找。
>
>
>
>还有，如果是这个事务自己更新的数据，它自己还是要认的。 

在实现上， InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务 ID。“活跃”指的就是，启动了但还没提交。

数组里面事务 ID 的最小值记为低水位，当前系统里面已经创建过的事务 ID 的最大值加 1记为高水位。

这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。
而数据版本的可见性规则，就是基于数据的 row trx_id 和这个一致性视图的对比结果得到的。
这个视图数组把所有的 row trx_id 分成了几种不同的情况。  

![数据版本可见性规则.PNG](https://github.com/ZEQINLIN-666/MyNotes/blob/main/image/%E6%95%B0%E6%8D%AE%E7%89%88%E6%9C%AC%E5%8F%AF%E8%A7%81%E6%80%A7%E8%A7%84%E5%88%99.PNG?raw=true)

1. 如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；

2. <u>**如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；**</u>

3. 如果落在黄色部分，那就包括两种情况

   ​	<u>**a. 若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见；**</u>
   ​	b. 若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。

比如，对于图 2 中的数据来说，如果有一个事务，它的低水位是 18，那么当它访问这一行数据时，就会从 V4 通过 U3 计算出 V3，所以在它看来，这一行的值是 11。



有了这个声明后，系统里面随后发生的更新，就跟这个事务看到的内容无关了。

因为之后的更新，生成的版本一定属于上面的 2 或者 3(a) 的情况，而对它来说，这些新的数据版本是不存在的，所以这个事务的快照，就是“静态”的了  。

---

**<u>InnoDB利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力。</u>**



**4.解释为什么事务B查到的k=3，而事务A 查到的k = 1；**

这里，我们不妨做如下假设：

1. 事务 A 开始前，系统里面只有一个活跃事务 ID 是 99；
2. 事务 A、B、C 的版本号分别是 100、101、102，且当前系统里只有这四个事务；三个事务开始前，(1,1）这一行数据的 row trx_id 是 90。
3. 这样，**<u>事务 A 的视图数组就是 [99,100], 事务 B 的视图数组是 [99,100,101], 事务 C 的视图数组是 [99,100,101,102]。</u>**

为了简化分析，我先把其他干扰语句去掉，只画出跟事务 A 查询逻辑有关的操作：  

![事务A查询数据逻辑图.PNG](https://github.com/ZEQINLIN-666/MyNotes/blob/main/image/%E4%BA%8B%E5%8A%A1A%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E9%80%BB%E8%BE%91%E5%9B%BE.PNG?raw=true)

**1.在数据对比的角度分析上图**：

从图中可以看到，第一个有效更新是事务 C，把数据从 (1,1) 改成了 (1,2)。这时候，这个数据的最新版本的 row trx_id 是 102，而 90 这个版本已经成为了历史版本。

第二个有效更新是事务 B，把数据从 (1,2) 改成了 (1,3)。这时候，这个数据的最新版本（即
row trx_id）是 101，而 102 又成为了历史版本。

在事务 A 查询的时候，其实事务 B 还没有提交，但是它生成的 (1,3) 这个版本已经变成当前版本了。但这个版本对事务 A 必须是不可见的，否则就变成脏读了。

好，现在事务 A 要来读数据了，它的视图数组是 [99,100]。当然了，读数据都是从当前版本读起的。所以，事务 A 查询语句的读数据流程是这样的  

1. <u>找到 (1,3) 的时候，判断出 row trx_id=101，比高水位大，处于红色区域，不可见；</u>  
2. <u>找到上一个历史版本，一看 row trx_id=102，比高水位大，处于红色区域，不可见；</u>  
3. <u>再往前找，终于找到了（1,1)，它的 row trx_id=90，比低水位小，处于绿色区域，可见</u>  

**这样执行下来，虽然期间这一行数据被修改过，但是事务 A 不论在什么时候查询，看到这行数据的结果都是一致的，所以我们称之为一致性读。**  



**2.从时间先后的角度分析上图：**

>一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况：（下文说的情况1，2，3指的是下面三种情况。）
>
>1. 版本未提交，不可见；
>
>2. 版本已提交，但是是在视图创建后提交的，不可见；
>3. 版本已提交，而且是在视图创建前提交的，可见。  

我们用这个规则来判断上图的查询结果，事务 A 的查询语句的视图数组是在事务A 启动的时候生成的，这时候：  

- (1,3) 还没提交，属于情况 1，不可见；
- (1,2) 虽然提交了，但是是在视图数组创建之后提交的，属于情况 2，不可见；
- (1,1) 是在视图数组创建之前提交的，可见。  





### 事务的更新逻辑（当前读）

**问题：事务 B 的 update 语句，如果按照一致性读，好像结果不对哦？**
在事务B的更新逻辑图中，事务 B 的视图数组是先生成的，之后事务 C 才提交，不是应该看不见 (1,2)
吗，怎么能算出 (1,3) 来？  

![事务B更新逻辑图.PNG](https://github.com/ZEQINLIN-666/MyNotes/blob/main/image/%E4%BA%8B%E5%8A%A1B%E6%9B%B4%E6%96%B0%E9%80%BB%E8%BE%91%E5%9B%BE.PNG?raw=true)

是的，如果事务 B 在更新之前查询一次数据，这个查询返回的 k 的值确实是 1。
但是，当它要去更新数据的时候，就不能再在历史版本上更新了，否则事务 C 的更新就丢失了。因此，事务 B 此时的 set k=k+1 是在（1,2）的基础上进行的操作。

所以，这里就用到了这样一条规则：**更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。**
因此，在**更新**的时候，当前读拿到的数据是 (1,2)，**更新后生成了新版本的数据 (1,3)，这个新版本的 row trx_id 是 101。**
所以，在执行事务 B **查询语句**的时候，一看自己的版本号是 101，最新数据的版本号也是101，是自己的更新，可以直接使用，所以查询得到的 k 的值是 3。  

>除了 update 语句外，select 语句如果加锁，也是当前读 。
>
>所以，如果把事务 A 的查询语句 select * from t where id=1 修改一下，加上 lock in share mode 或 for update，也都可以读到版本号是 101 的数据，返回的 k 的值是 3。下面这两个 select 语句，就是分别加了读锁（S 锁，共享锁）和写锁（X 锁，排他锁）。 
>
>```mysql
>select k from t where id=1 lock in share mode;
>select k from t where id=1 for update;
>```



**假设事务 C 不是马上提交的，而是变成了下面的事务 C’，会怎么样呢？**  

![事务A,B,C'的执行流程.PNG](https://github.com/ZEQINLIN-666/MyNotes/blob/main/image/%E4%BA%8B%E5%8A%A1A,B,C'%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.PNG?raw=true)

事务 C’的不同是，更新后并没有马上提交，在它提交前，事务 B 的更新语句先发起了。

前面说过了，虽然事务 C’还没提交，但是 (1,2) 这个版本也已经生成了，并且是当前的最新版本。那么，事务 B 的更新语句会怎么处理呢？

这时候，“两阶段锁协议”就要上场了。事务 C’没提交，也就是说 (1,2) 这个版本上的写锁还没释放。

**<u>而事务 B是更新语句， 是当前读，必须要读最新版本，而且必须加锁。</u>**

因此就被锁住了，必须等到事务 C’释放这个锁，才能继续它的当前读。  

![事务B更新逻辑图（配合事务C'）.PNG](https://github.com/ZEQINLIN-666/MyNotes/blob/main/image/%E4%BA%8B%E5%8A%A1B%E6%9B%B4%E6%96%B0%E9%80%BB%E8%BE%91%E5%9B%BE%EF%BC%88%E9%85%8D%E5%90%88%E4%BA%8B%E5%8A%A1C'%EF%BC%89.PNG?raw=true)



### 事务的可重复读的能力是怎么实现的？  

**可重复读的核心就是一致性读（consistent read）；**

而**事务更新数据的时候，只能用当前读。**如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。  



而读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：  

- 在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；
- 在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。  





那么，我们再看一下，在读提交隔离级别下，事务 A 和事务 B 的查询语句查到的 k，分别应该是多少呢？

这里需要说明一下，`start transaction with consistent snapshot; `的意思是从这个语句开始，创建一个持续整个事务的一致性快照。

所以，在读提交隔离级别下，这个用法就没意义了，等效于普通的` start transaction`。

下面是读提交时的状态图，可以看到这两个查询语句的创建视图数组的时机发生了变化，就是图中的 read view 框。（注意：这里，我们用的还是事务 C 的逻辑直接提交，而不是事务 C’）  

![读提交隔离级别下的事务状态图.PNG](https://github.com/ZEQINLIN-666/MyNotes/blob/main/image/%E8%AF%BB%E6%8F%90%E4%BA%A4%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8B%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%8A%B6%E6%80%81%E5%9B%BE.PNG?raw=true)

这时，事务 A 的查询语句的视图数组是在执行这个语句的时候创建的，时序上 (1,2)、(1,3)的生成时间都在创建这个视图数组的时刻之前。但是，在这个时刻：

- (1,3) 还没提交，属于情况 1(***版本未提交***)，不可见  ;
- (1,2) 提交了，属于情况 3(***版本已提交，而且是在视图创建前提交的***)，可见  

所以，这时候事务 A 查询语句返回的是 k=2。
显然地，事务 B 查询结果 k=3  



---

### 小结

InnoDB 的行数据有多个版本，每个数据版本有自己的 row trx_id，每个事务或者语句有自己的一致性视图。

**<u>普通查询语句是一致性读，一致性读会根据 row trx_id 和一致性视图确定数据版本的可见性</u>**。

- 对于**可重复读(RR)**，**查询**只承认**<u>在事务启动前</u>**就已经提交完成的数据；
- 对于**读提交(RC)**，**查询**只承认**<u>在语句启动前</u>**就已经提交完成的数据；  

而当前读，总是读取已经提交完成的最新版本。

你也可以想一下，为什么表结构不支持“可重复读”？

这是因为表结构没有对应的行数据，也没有 row trx_id，因此只能遵循当前读的逻辑。

> 当然，MySQL 8.0 已经可以把表结构放在 InnoDB 字典里了，也许以后会支持表结构的可重复读。

